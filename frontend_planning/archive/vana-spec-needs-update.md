### **System Architecture & Component Specification: Gemini-style Chat Agent**

1\. Project Overview  
This document provides a complete technical specification for the AI chat agent project. It is intended for designers, frontend developers, and backend developers to ensure a shared understanding of all system components, their functions, and their interactions. The goal is to build a web application that replicates the core functionality and user experience of the Google Gemini interface, powered by a custom Google ADK-based agent.  
2\. System Architecture Diagram  
The following diagram illustrates the end-to-end data flow of the application, from the user's browser to the backend services and back.  
graph TD  
    subgraph User's Browser  
        A\[Next.js/React Frontend\]  
    end

    subgraph Authentication  
        B\[Firebase Auth\]  
    end

    subgraph "Backend Services on GCP"  
        C\[FastAPI on Cloud Run\]  
        D\[Google ADK Agent\]  
        E\[LiteLLM\]  
        F\[LLM Providers \<br/\>(OpenRouter, Vertex AI)\]  
        G\[Firestore / Cloud SQL\]  
        H\[Google Cloud Storage\]  
    end

    A \-- Authenticates with \--\> B;  
    A \-- "Sends JWT \+ Prompt" \--\> C;  
    C \-- "Verifies JWT" \--\> B;  
    C \-- "Forwards Request" \--\> D;  
    D \-- "Uses Tools & Logic" \--\> E;  
    E \-- "Routes to" \--\> F;  
    D \-- "Stores/Retrieves History" \--\> G;  
    D \-- "Stores/Retrieves Files" \--\> H;  
    F \-- "Streams Response" \--\> E;  
    E \-- "Streams Response" \--\> D;  
    D \-- "Streams Response" \--\> C;  
    C \-- "Streams SSE Response" \--\> A;

* **User Interaction**: The user interacts with a **Next.js/React** single-page application running in their browser.  
* **Authentication**: All interactions are authenticated through **Firebase Auth**. The Next.js client obtains a JWT token upon login, which is sent with every API request.  
* **API Gateway**: The backend, built with **FastAPI**, serves as the primary API gateway. It runs on **Google Cloud Run** and is responsible for validating the Firebase JWT and routing requests.  
* **Agent Orchestration**: The FastAPI backend hands off requests to the **Google Agent Development Kit (ADK)** agent.  
* **LLM Communication**: The ADK agent uses **LiteLLM** as a universal interface to communicate with various large language models available through services like **OpenRouter** or directly via **Vertex AI**.  
* **Real-time Response**: For streaming responses, the FastAPI backend establishes a **Server-Sent Event (SSE)** connection with the client, pushing tokens as they are generated by the LLM.  
* **Data Persistence**:  
  * **Session History**: Conversation logs and metadata are persisted in a structured database like **Firestore** or **Cloud SQL** for fast retrieval.  
  * **File Artifacts**: Larger files uploaded through the Canvas feature (images, documents) are stored in **Google Cloud Storage (GCS)**, with their URIs referenced in the session history.

### **3\. Frontend Specification**

The frontend is a modern, responsive web application designed for a seamless conversational experience.

* **Core Stack**: Next.js (React), TypeScript, Tailwind CSS  
* **UI Libraries**: Shadcn/UI, Assistant UI, Kibo UI, AI SDK Elements  
* **State Management**: Zustand for global state management.

#### **3.1. Theme & Styling (Gemini Aesthetic)**

To ensure visual consistency with the target design, the following theme should be implemented. These values should be configured in tailwind.config.js and the global CSS file (globals.css).  
Typography

* **Primary Font**: Google Sans, Inter, sans-serif  
  * Note: Google Sans is the ideal font. Inter should be used as the primary web-safe fallback.

**Color Palette (Dark Mode)**

| Role | Hex Code | Tailwind Utility Suggestion | Description |
| :---- | :---- | :---- | :---- |
| **Background** | \#131314 | bg-background | Main app background color. |
| **UI/Card Background** | \#1E1F20 | bg-card | Background for sidebars, cards, and input areas. |
| **Primary Text** | \#E3E3E3 | text-foreground | For body text and primary content. |
| **Secondary Text** | \#C4C7C5 | text-muted-foreground | For labels, descriptions, and less important text. |
| **Borders/Dividers** | \#444746 | border | For all borders and dividing lines. |
| **Accent Gradient (Start)** | \#89B5F7 | from-blue-400 | Start color for primary buttons and highlights. |
| **Accent Gradient (End)** | \#546CEE | to-purple-500 | End color for primary buttons and highlights. |

#### **3.2. State Management Strategy**

For an application of this complexity, **Zustand is the recommended library for global state management**. It prevents common performance bottlenecks associated with React Context by allowing components to subscribe to granular state changes, which is essential for the planned real-time UI updates.

* **Initial State Structure**: The global store should be initialized with a structure similar to the following:  
  import { create } from 'zustand';

  interface AppState {  
    activeView: 'conversation' | 'canvas';  
    canvasContent: {  
      content: string;  
      type: 'code' | 'markdown' | 'diagram' | 'webpage' | null;  
    };  
    chatHistory: any\[\]; // Define a proper type for messages  
    agentPlan: object | null;  
    isLoading: boolean;  
    // ... other state management functions  
  }

  export const useAppStore \= create\<AppState\>((set) \=\> ({  
    activeView: 'conversation',  
    canvasContent: { content: '', type: null },  
    chatHistory: \[\],  
    agentPlan: null,  
    isLoading: false,  
  }));

#### **3.3. Environment Variable Management**

To ensure security and flexibility across different deployment environments (development, staging, production), the frontend must externalize configuration variables.

* **Implementation**: Use Next.js's built-in support for environment variables by creating a .env.local file at the root of the project. This file should be included in .gitignore to prevent committing secrets to version control.  
* **Example .env.local**:  
  NEXT\_PUBLIC\_API\_BASE\_URL=\[http://127.0.0.1:8000\](http://127.0.0.1:8000)  
  NEXT\_PUBLIC\_FIREBASE\_API\_KEY=your-firebase-api-key

  These variables can then be accessed in the application code via process.env.NEXT\_PUBLIC\_API\_BASE\_URL.

#### **3.4. Error Handling and User Feedback**

A robust error handling strategy is critical for a good user experience. The application should provide clear feedback for both minor and critical errors.

* **Non-Blocking Notifications**: For API errors or other non-critical issues, use a "toast" notification system. **Sonner** is recommended as it integrates seamlessly with Shadcn/UI and provides a clean, simple API.  
* **Critical Failures**: To prevent the entire application from crashing due to a rendering error in a specific component, wrap key UI sections (like the main chat thread or canvas) in **React Error Boundaries**. An error boundary is a React component that catches JavaScript errors anywhere in its child component tree, logs those errors, and displays a fallback UI.

#### **3.5. Component Inventory**

| Feature/View | UI Element | Component/Library | Source | Notes for Designer |
| :---- | :---- | :---- | :---- | :---- |
| **Global Layout** | Main two-column structure | CSS Flexbox / Grid | \- | The left sidebar should be collapsible to maximize content area. |
| **Sidebar** | Chat History Sidebar | AssistantSidebar (Assistant UI) | [Link](https://www.google.com/search?q=https://www.assistant-ui.com/docs/ui/assistant-sidebar) | Pre-built component for managing new and recent chats. |
|  | User Profile Menu | Avatar \+ DropdownMenu (Shadcn) | [Link](https://ui.shadcn.com/docs/components/dropdown-menu) | Shows user avatar; dropdown contains "Settings" (links to User Profile View) and "Sign Out". |
| **Welcome Screen** | Greeting Text | \<h1\>, \<p\> | \- | Centered, welcoming message for new chat sessions. |
|  | Prompt Suggestion Cards | Card (Shadcn) | [Link](https://ui.shadcn.com/docs/components/card) | A grid of 4 cards, each with an icon (lucide-react) and text. |
| **Conversation View** | Chat Thread | Thread (Assistant UI) | [Link](https://www.assistant-ui.com/docs/ui/Thread) | Pre-built component for rendering the entire conversation flow. |
|  | Rendered Code Snippet | Code Block (Kibo UI) | [Link](https://www.kibo-ui.com/components/code-block) | Renders code within the chat thread. |
|  | Rendered Formatted Text | Custom Component | \- | Renders rich text (reports, documents) within the chat thread. |
|  | Rendered Diagram | Mermaid (Assistant UI) | [Link](https://www.assistant-ui.com/docs/ui/Mermaid) | Renders a Mermaid diagram within the chat thread. |
|  | Multi-Agent Status Plan | Agent Plan (aceternity/21st.dev) | [Link](https://21st.dev/isaiahbjork/agent-plan/default) | Renders a detailed, step-by-step plan for a multi-agent task directly in the chat thread. |
| **Global UI** | Multi-Agent Progress Deck | Card Stack (aceternity/21st.dev) | [Link](https://21st.dev/aceternity/card-stack/default) | A dynamic, animated stack of cards that appears as an overlay to provide visual feedback, working in sync with the Agent Plan. |
| **Chat Input Bar** | Main Input Form | Custom Component | \- | A styled container fixed to the bottom of the screen. |
|  | Text Input Field | Textarea (Shadcn) | [Link](https://ui.shadcn.com/docs/components/textarea) | Must auto-resize vertically based on content. |
|  | Simple File Attachment | Button (Shadcn) | [Link](https://ui.shadcn.com/docs/components/button) | Icon-only button to attach a file to a prompt (does not open Canvas). |
|  | Send Button | Button (Shadcn) | [Link](https://ui.shadcn.com/docs/components/button) | Primary action to submit the prompt. Disabled when input is empty. |
| **User Profile View** | Main Layout | User Profile Block (shadcn-ui-blocks) | [Link](https://www.shadcn-ui-blocks.com/blocks/user-profiles) | A dedicated page for user settings, accessed from the sidebar menu. Composed of standard shadcn components. |
|  | Navigation Tabs | Tabs (Shadcn) | [Link](https://ui.shadcn.com/docs/components/tabs) | For switching between sections like "Profile," "Account," "Appearance." |
|  | Form Layout | Card, Input, Label (Shadcn) | [Link](https://ui.shadcn.com/docs/components/card) | Standard form elements for updating user information like name, email. |
|  | Action Buttons | Button (Shadcn) | [Link](https://ui.shadcn.com/docs/components/button) | "Save Changes," "Cancel," etc. |
| **Canvas View** | Main Canvas Container | Card (Shadcn) | [Link](https://ui.shadcn.com/docs/components/card) | A full-screen view that replaces the Conversation View when active. |
|  | Code Editor | @monaco-editor/react | [Link](https://github.com/suren-atoyan/monaco-react) | The editor for viewing/editing code within the Canvas. |
|  | Markdown Editor | Markdown (Assistant UI) | [Link](https://www.assistant-ui.com/docs/ui/Markdown) | The editor for viewing/editing formatted Markdown documents within the Canvas. |
|  | Diagram Editor | Mermaid (Assistant UI) | [Link](https://www.assistant-ui.com/docs/ui/Mermaid) | The editor for viewing/editing Mermaid diagrams within the Canvas. |
|  | Interactive Preview Pane | Sandbox (Kibo UI) | [Link](https://www.kibo-ui.com/components/sandbox) | Renders a **live, interactive preview** of safe, client-side code from the Code Editor. For the development loop. |
|  | Final Web Page Preview | WebPreview (AI SDK) | [Link](https://ai-sdk.dev/elements/components/web-preview) | Renders a **final, static preview** of a complete HTML string or URL. For displaying finished products. |
|  | Canvas Toolbar | Custom Component | \- | Contains buttons like "Preview," "Copy," and "Return to Chat." |

### **4\. Backend Specification**

The backend is a collection of scalable, serverless microservices orchestrated to power the agent's logic and data management.

* **Core Stack**: Python, FastAPI  
* **Platform**: Google Cloud Platform (GCP)

#### **4.1. Service Inventory**

| Service | Technology | Function |
| :---- | :---- | :---- |
| **Authentication Gateway** | FastAPI Middleware \+ Firebase Admin SDK | Verifies the JWT token on every incoming API request to secure endpoints. |
| **Agent API** | FastAPI \+ Google ADK | Exposes primary endpoints (/chat, /stream). **Must support flags for Direct-to-Canvas flow and streaming structured updates for multi-agent status.** |
| **Model Abstraction** | LiteLLM | Provides a unified API for the ADK agent to call any supported LLM (via OpenRouter, Vertex AI, etc.). |
| **Streaming Service** | FastAPI (Server-Sent Events) | Manages persistent SSE connections to clients for streaming token-by-token responses and structured status updates. |
| **Session Persistence** | Firestore / Cloud SQL | Stores, retrieves, and updates conversation history (messages, tool calls, metadata). |
| **Artifact Storage** | Google Cloud Storage (GCS) | Manages the upload, storage, and retrieval of user-provided files (images, docs). |
| **Monitoring & Analytics** | OpenTelemetry, Cloud Trace, BigQuery | Collects traces, logs, and metrics for performance monitoring and usage analysis. |

#### **4.2. Google ADK Integration & Best Practices**

This section details how the core concepts of the Google Agent Development Kit (ADK) will be applied in our backend, following best practices from the official documentation and sample implementations like the gemini-fullstack agent.  
graph TD  
    subgraph ADK Reasoning Loop  
        M\[Measurement \<br/\> \<i\>(e.g., User Prompt)\</i\>\] \--\> A{Agent};  
        A \-- Chooses \--\> AC(Action);  
        AC \-- Executes \--\> M\_OUT\[Measurement \<br/\> \<i\>(e.g., Tool Output)\</i\>\];  
        M\_OUT \--\> A;  
    end

* **Measurements**: These are the strongly-typed data structures that carry information through the agent system.  
  * **Application**: When the FastAPI backend receives a request, it will translate the user's prompt and any attached files into ADK Measurement objects. For example, user\_prompt \= adk.Measurement("user\_prompt", "The user's text query", str). This ensures that data passed to the agent is explicit and well-defined. The output of every tool is also a Measurement.  
* **Actions (Tools)**: These are the fundamental capabilities of our agent. An action is a simple Python function decorated with @adk.action.  
  * **Application**: All of the agent's tools (Web Search, File System Access, Code Execution) will be implemented as ADK Actions. The decorator allows the ADK to automatically understand the tool's purpose, its inputs (which Measurements it needs), and its outputs (which Measurements it produces). This is how the agent can reason about which tool to use for a given task.  
* **Agent**: This is the core reasoning engine, powered by an LLM, that orchestrates the entire process.  
  * **Application**: We will create an adk.Agent and provide it with the list of all available Actions. When the agent receives an initial Measurement (the user's prompt), its reasoning loop will be triggered. It will analyze the available data and choose the most appropriate Action to execute next, continuing this loop until it has enough information to generate a final response.  
* **Multi-Agent Orchestration**: Following the gemini-fullstack pattern, complex tasks will be handled by a primary "Orchestrator" agent.  
  * **Application**: This Orchestrator agent will not perform tasks itself. Instead, its tools will be other, more specialized agents (e.g., a "Research Agent," a "Coding Agent"). The Orchestrator's job is to break down the user's request, delegate sub-tasks to the appropriate specialized agent, and synthesize their results into a final answer. The frontend's Agent Plan and Card Stack components are designed to visualize this exact process.

### **5\. Implementation Specification: Agent-Driven Workflows**

#### **5.1. Interactive Canvas Workflow**

The core principle is that the **Canvas is a destination for agent-generated content**, not a tool the user invokes from a blank state.  
sequenceDiagram  
    participant User  
    participant Frontend  
    participant Backend (ADK Agent)

    alt In-Chat Content to Canvas  
        User-\>\>Frontend: Asks for code snippet  
        Frontend-\>\>Backend: Sends prompt  
        Backend--\>\>Frontend: Streams response with code  
        Frontend-\>\>User: Renders code in chat with "Open in Canvas" button  
        User-\>\>Frontend: Clicks "Open in Canvas"  
        Frontend-\>\>Frontend: Sets global state with code  
        Frontend-\>\>User: Switches to Canvas View with code pre-populated  
    end

    alt Direct-to-Canvas  
        User-\>\>Frontend: Asks for a full website  
        Frontend-\>\>Backend: Sends prompt  
        Backend--\>\>Frontend: Sends final response with \`displayMode: "canvas"\` flag  
        Frontend-\>\>Frontend: Sets global state with website code  
        Frontend-\>\>User: Switches directly to Canvas View with code pre-populated  
    end

* **Global** View **State**: The application must have a global state (managed by Zustand) that controls whether the Conversation View or the Canvas View is active.  
* **Canvas Content State**: A separate global state is required to hold the content (code, markdown, etc.) and its type to be displayed when the Canvas View becomes active.

**Flow 1: In-Chat Content to Canvas (User-Initiated Transfer)**

1. **Agent Response**: The agent generates content (e.g., a Python script) and sends it to the frontend.  
2. **Frontend Rendering**: The Thread component receives the message object. It renders the primary content (e.g., the code snippet inside a CodeBlock component) and, conditionally, renders an "Open in Canvas" button *alongside* it within the message bubble. **This** button is part of the chat message's UI, not the content block itself, **ensuring separation of concerns.**  
3. **User Action**: When the user clicks the button, a handler function updates the global Zustand store with the content and its type, then switches the activeView to 'canvas'.  
4. **Canvas Activation**: The main application layout, listening to the activeView state, unmounts the ConversationView and mounts the CanvasView. The CanvasView then reads the canvasContent from the store and populates the appropriate editor.

**Flow 2: Direct-to-Canvas (Agent-Initiated View Change)**

1. **User Request**: The user makes a request that implies a large artifact (e.g., "Generate a complete website").  
2. **Agent Decision & API Response**: The backend agent decides the output requires a dedicated workspace and sends a special flag in its response (e.g., { "displayMode": "canvas", "content": "...", "contentType": "webpage" }).  
3. **Frontend Logic**: The frontend checks for this flag, sets the global state for both canvasContent and activeView, and immediately switches to the Canvas View, rendering the appropriate component (Monaco Editor, WebPreview, etc.).

#### **5.2. Multi-Agent Status Display Workflow**

This workflow provides clear, real-time feedback when the backend engages a multi-agent team.  
sequenceDiagram  
    participant User  
    participant Frontend  
    participant Backend (ADK Agent)

    User-\>\>Frontend: Submits complex prompt  
    Frontend-\>\>Backend: Sends prompt  
    Backend--\>\>Frontend: Streams initial plan (JSON)  
    Frontend-\>\>User: Renders "Agent Plan" in chat AND "Card Stack" overlay  
    loop For each step  
        Backend--\>\>Frontend: Streams status update (JSON)  
        Frontend-\>\>Frontend: Updates state of both components  
        Frontend-\>\>User: Animates "Agent Plan" and "Card Stack"  
    end  
    Backend--\>\>Frontend: Streams final result  
    Frontend-\>\>User: Hides "Card Stack" and shows final result in chat

1. **Agent Task Initiation**: The user submits a complex prompt requiring multiple steps.  
2. **Backend Response (Initial Plan)**: The ADK agent's first response is a structured message containing the entire plan.  
   * **Example Payload**: { "type": "agent\_plan", "title": "Researching Full-Stack Solutions", "steps": \["Analyze requirements", "Draft backend code", "Develop frontend UI", "Test integration"\] }  
3. **Frontend Rendering (Dual Components)**:  
   * **In-Chat Agent Plan**: The Thread component receives this payload and renders the Agent Plan UI, displaying all steps with a "pending" status.  
   * **Card Stack Overlay**: Simultaneously, the frontend renders the Card Stack component (e.g., as a dismissible overlay in the corner), populated with cards corresponding to the steps from the plan.  
4. **Backend Response (Streaming Updates)**: As the agent progresses, the backend streams simple status update messages.  
   * **Example Payloads**: { "type": "plan\_update", "step": 1, "status": "in\_progress" }, { "type": "plan\_update", "step": 1, "status": "complete" }, { "type": "plan\_update", "step": 2, "status": "in\_progress" }  
5. **Synchronized UI Updates**: The frontend listens for these updates and updates both components in real-time:  
   * The Agent Plan in the chat updates the icon for the corresponding step (e.g., from pending to a spinner, then to a checkmark).  
   * The Card Stack animates, shuffling the card for the completed step to the back of the deck, bringing the new "in-progress" task to the front.  
6. **Task Completion**: Once all steps are complete, the Card Stack can animate away, and the Agent Plan shows all steps as completed.