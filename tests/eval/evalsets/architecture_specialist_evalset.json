{
  "eval_set_id": "architecture_specialist_evaluation",
  "name": "Architecture Specialist Agent Evaluation",
  "description": "Tests the architecture specialist's ability to provide comprehensive system design guidance and technical recommendations",
  "eval_cases": [
    {
      "eval_id": "arch_001",
      "conversation": [
        {
          "user_content": {
            "parts": [{"text": "Design a scalable microservices architecture for a high-traffic social media platform"}],
            "role": "user"
          },
          "final_response": {
            "parts": [{"text": "I'll design a scalable microservices architecture for a high-traffic social media platform. Here's a comprehensive approach:\n\n**Core Microservices:**\n\n1. **User Service**\n   - User registration, authentication, profiles\n   - OAuth integration, JWT token management\n   - User preferences and privacy settings\n\n2. **Content Service**\n   - Post creation, editing, deletion\n   - Media upload and processing\n   - Content moderation and filtering\n\n3. **Feed Service**\n   - Timeline generation and caching\n   - Personalized content ranking\n   - Real-time feed updates\n\n4. **Social Graph Service**\n   - Friend/follower relationships\n   - Social network analysis\n   - Connection recommendations\n\n5. **Notification Service**\n   - Push notifications, email, SMS\n   - Real-time alerts and updates\n   - Notification preferences\n\n6. **Analytics Service**\n   - User behavior tracking\n   - Content performance metrics\n   - Business intelligence\n\n**Architecture Patterns:**\n\n- **Event-Driven Architecture**: Apache Kafka for real-time event streaming\n- **CQRS**: Separate read/write models for high-performance queries\n- **Database per Service**: PostgreSQL for transactional data, Redis for caching\n- **API Gateway**: Kong or AWS API Gateway for request routing\n- **Circuit Breaker**: Hystrix pattern for fault tolerance\n\n**Scalability Solutions:**\n\n- **Horizontal Scaling**: Kubernetes auto-scaling based on metrics\n- **Database Sharding**: Partition user data across multiple databases\n- **CDN**: CloudFlare for global content delivery\n- **Caching Strategy**: Multi-level caching (Redis, CDN, application-level)\n- **Load Balancing**: NGINX with health checks and failover\n\n**High-Traffic Optimizations:**\n\n- **Read Replicas**: Multiple database read replicas for query distribution\n- **Message Queues**: RabbitMQ for asynchronous processing\n- **Search Engine**: Elasticsearch for fast content search\n- **Media Processing**: Separate service for image/video processing\n- **Rate Limiting**: API rate limiting to prevent abuse\n\n**Monitoring & Observability:**\n\n- **Metrics**: Prometheus + Grafana for system monitoring\n- **Logging**: ELK stack for centralized logging\n- **Tracing**: Jaeger for distributed tracing\n- **Health Checks**: Comprehensive health monitoring\n\n**Security Considerations:**\n\n- **Authentication**: OAuth 2.0 with JWT tokens\n- **Authorization**: Role-based access control (RBAC)\n- **Data Encryption**: TLS in transit, AES-256 at rest\n- **Input Validation**: Comprehensive input sanitization\n- **DDoS Protection**: CloudFlare DDoS mitigation\n\nThis architecture can handle millions of users with high availability and performance."}],
            "role": "model"
          },
          "intermediate_data": {
            "tool_uses": []
          }
        }
      ]
    },
    {
      "eval_id": "arch_002",
      "conversation": [
        {
          "user_content": {
            "parts": [{"text": "How would you implement a real-time chat system with message persistence and offline support?"}],
            "role": "user"
          },
          "final_response": {
            "parts": [{"text": "I'll design a real-time chat system with message persistence and offline support. Here's a comprehensive architecture:\n\n**Real-Time Communication:**\n\n1. **WebSocket Connections**\n   - Socket.IO for cross-platform compatibility\n   - Connection pooling and load balancing\n   - Automatic reconnection with exponential backoff\n   - Heartbeat mechanism for connection health\n\n2. **Message Broker**\n   - Redis Pub/Sub for real-time message distribution\n   - Apache Kafka for message persistence and replay\n   - Message routing based on chat rooms/channels\n\n**Message Persistence:**\n\n1. **Database Design**\n   - **Primary**: PostgreSQL for message storage\n   - **Schema**: messages(id, chat_id, user_id, content, timestamp, message_type)\n   - **Indexing**: Composite indexes on (chat_id, timestamp) for fast retrieval\n   - **Partitioning**: Time-based partitioning for large datasets\n\n2. **Message Storage Strategy**\n   - Immediate persistence to database\n   - Redis caching for recent messages (last 100 per chat)\n   - Message deduplication using unique message IDs\n   - Batch processing for analytics and search indexing\n\n**Offline Support:**\n\n1. **Client-Side Storage**\n   - IndexedDB for message caching\n   - Service Workers for background sync\n   - Local message queue for offline composition\n   - Conflict resolution for simultaneous edits\n\n2. **Synchronization Strategy**\n   - Message versioning with vector clocks\n   - Delta sync to minimize data transfer\n   - Automatic sync on reconnection\n   - Push notifications for missed messages\n\n**Architecture Components:**\n\n1. **Chat Service**\n   - Message validation and processing\n   - User presence management\n   - Chat room management\n   - Message encryption/decryption\n\n2. **Presence Service**\n   - Online/offline status tracking\n   - Last seen timestamps\n   - Typing indicators\n   - User activity monitoring\n\n3. **Notification Service**\n   - Push notifications for offline users\n   - Email notifications for important messages\n   - In-app notification management\n\n**Scalability Features:**\n\n- **Horizontal Scaling**: Stateless chat servers behind load balancer\n- **Database Sharding**: Shard by chat_id for even distribution\n- **CDN**: Media message delivery through CDN\n- **Caching**: Multi-level caching strategy\n- **Message Queuing**: Asynchronous processing for heavy operations\n\n**Security & Privacy:**\n\n- **End-to-End Encryption**: Signal Protocol implementation\n- **Message Authentication**: HMAC for message integrity\n- **Rate Limiting**: Prevent spam and abuse\n- **Content Moderation**: Automated filtering and human review\n\nThis architecture ensures reliable, scalable real-time communication with robust offline capabilities."}],
            "role": "model"
          },
          "intermediate_data": {
            "tool_uses": []
          }
        }
      ]
    }
  ]
}
