/**
 * Artifact Executor - Pure Business Logic for Artifact Generation
 *
 * This module handles the core artifact generation logic without HTTP/CORS concerns.
 * It is designed to be used by multiple HTTP endpoints (generate-artifact, chat/tool-calling-chat).
 *
 * RESPONSIBILITIES:
 * - Construct prompts based on artifact type
 * - Call GLM API with retry logic
 * - Parse and validate responses
 * - Auto-fix common issues
 * - Track token usage and costs
 *
 * NOT RESPONSIBLE FOR (handled by caller):
 * - HTTP request/response handling
 * - CORS headers
 * - Authentication
 * - Rate limiting
 * - SSE streaming (caller transforms result into SSE events)
 *
 * @module artifact-executor
 * @since 2025-12-19
 */

import {
  callGLMWithRetryTracking,
  extractTextAndReasoningFromGLM,
  extractGLMTokenUsage,
  calculateGLMCost,
} from './glm-client.ts';
import {
  validateArtifactCode,
  autoFixArtifactCode,
  preValidateAndFixGlmSyntax,
} from './artifact-validator.ts';
import { getSystemInstruction } from './system-prompt-inline.ts';
import { MODELS, ARTIFACT_TYPES, type ArtifactType } from './config.ts';
import { ErrorCode } from './error-handler.ts';
import type { StructuredReasoning } from './reasoning-generator.ts';

// ============================================================================
// SECURITY CONSTANTS
// ============================================================================

/**
 * Maximum prompt length to prevent resource exhaustion attacks
 * ~2,500 tokens at 4 chars/token average
 */
const MAX_PROMPT_LENGTH = 10000;

/**
 * Maximum request ID length to prevent log injection
 */
const MAX_REQUEST_ID_LENGTH = 64;

/**
 * Artifact types that can be generated by this executor
 * (excludes 'image' which uses a separate pipeline)
 */
export type GeneratableArtifactType = Exclude<ArtifactType, 'image'>;
const GENERATABLE_ARTIFACT_TYPES = new Set<GeneratableArtifactType>([
  'react', 'html', 'svg', 'code', 'mermaid', 'markdown'
]);

/**
 * Validate if a string is a valid artifact type
 * Used for defense-in-depth input validation in tool-executor
 *
 * @param type - String to validate
 * @returns True if type is a valid GeneratableArtifactType
 */
export function isValidArtifactType(type: string): type is GeneratableArtifactType {
  return GENERATABLE_ARTIFACT_TYPES.has(type as GeneratableArtifactType);
}

/**
 * Parameters for artifact generation
 */
export interface ArtifactExecutorParams {
  /**
   * The type of artifact to generate (excludes 'image' which uses separate pipeline)
   */
  type: GeneratableArtifactType;

  /**
   * User's prompt describing what to create
   */
  prompt: string;

  /**
   * Request ID for tracking and logging
   */
  requestId: string;

  /**
   * Enable GLM thinking mode for better reasoning
   * @default true
   */
  enableThinking?: boolean;
}

/**
 * Result from artifact generation
 */
export interface ArtifactExecutorResult {
  /**
   * Generated artifact code (validated and auto-fixed)
   */
  artifactCode: string;

  /**
   * Raw reasoning text from GLM (null if thinking disabled)
   */
  reasoning: string | null;

  /**
   * Structured reasoning steps for UI display (null if thinking disabled)
   */
  reasoningSteps: StructuredReasoning | null;

  /**
   * Token usage statistics
   */
  tokenUsage: {
    inputTokens: number;
    outputTokens: number;
    totalTokens: number;
  };

  /**
   * Estimated cost in USD
   */
  estimatedCost: number;

  /**
   * Validation results
   */
  validation: {
    valid: boolean;
    autoFixed: boolean;
    issueCount: number;
  };

  /**
   * Total execution time in milliseconds
   */
  latencyMs: number;
}

/**
 * Custom error class for artifact execution failures
 */
export class ArtifactExecutionError extends Error {
  public readonly code: ErrorCode | string;
  public readonly requestId: string;

  constructor(
    message: string,
    code: ErrorCode | string,
    requestId: string,
    cause?: Error
  ) {
    super(message, { cause });
    this.name = 'ArtifactExecutionError';
    this.code = code;
    this.requestId = requestId;
  }
}

// ============================================================================
// SECURITY HELPERS
// ============================================================================

/**
 * Sanitize request ID to prevent log injection attacks
 * Removes control characters, newlines, and limits length
 */
function sanitizeRequestId(requestId: string): string {
  return requestId
    .replace(/[\x00-\x1F\x7F]/g, '') // Strip control characters
    .replace(/\r?\n/g, '') // Remove newlines
    .substring(0, MAX_REQUEST_ID_LENGTH); // Limit length
}

/**
 * Convert unknown error to Error instance
 * Type-safe error handling helper
 */
function toError(error: unknown): Error {
  return error instanceof Error ? error : new Error(String(error));
}

/**
 * Sanitize error messages to prevent information leakage
 * Removes potential secrets, file paths, and API URLs
 */
function sanitizeErrorMessage(message: string): string {
  return message
    .replace(/[a-zA-Z0-9_-]{32,}/g, '[REDACTED]') // API keys
    .replace(/Bearer\s+[^\s]+/gi, 'Bearer [REDACTED]') // Auth tokens
    .replace(/\/Users\/[^\s]+/g, '[PATH]') // File paths
    .replace(/https?:\/\/[^\s]+\/v\d+/g, '[API_ENDPOINT]'); // API URLs
}

/**
 * Validate input parameters before expensive operations
 * Implements fail-fast, fail-closed security pattern
 */
function validateParams(params: ArtifactExecutorParams, safeRequestId: string): void {
  const { type, prompt } = params;

  // Validate artifact type against whitelist
  if (!GENERATABLE_ARTIFACT_TYPES.has(type)) {
    throw new ArtifactExecutionError(
      `Invalid artifact type: ${type}`,
      ErrorCode.INVALID_INPUT,
      safeRequestId
    );
  }

  // Validate prompt is non-empty
  if (!prompt || prompt.trim().length === 0) {
    throw new ArtifactExecutionError(
      'Prompt cannot be empty',
      ErrorCode.INVALID_INPUT,
      safeRequestId
    );
  }

  // Validate prompt length to prevent resource exhaustion
  if (prompt.length > MAX_PROMPT_LENGTH) {
    throw new ArtifactExecutionError(
      `Prompt exceeds maximum length of ${MAX_PROMPT_LENGTH} characters`,
      ErrorCode.INVALID_INPUT,
      safeRequestId
    );
  }
}

/**
 * Construct the user prompt based on artifact type
 *
 * CRITICAL: GLM-4.6 tends to generate full HTML documents for React artifacts.
 * This prompt explicitly instructs it to return ONLY pure JSX/React code.
 *
 * @param prompt - User's description of what to create
 * @param type - Type of artifact to generate
 * @returns Formatted prompt for GLM
 */
function constructUserPrompt(prompt: string, type: GeneratableArtifactType): string {
  if (type === 'react') {
    return `Create a React component for: ${prompt}

CRITICAL FORMAT REQUIREMENTS:
1. Return ONLY pure JSX/React code - NO HTML document structure
2. Do NOT include <!DOCTYPE>, <html>, <head>, <body>, or <script> tags
3. Do NOT wrap the code in HTML - just the React component code
4. Start with imports or the component function directly
5. End with "export default ComponentName;" - nothing after that

CORRECT FORMAT EXAMPLE:
<artifact type="application/vnd.ant.react" title="My Component">
const { useState, useEffect } = React;

function App() {
  const [count, setCount] = useState(0);
  return (
    <div className="p-4">
      <h1>Count: {count}</h1>
      <button onClick={() => setCount(c => c + 1)}>Increment</button>
    </div>
  );
}

export default App;
</artifact>

WRONG FORMAT (DO NOT DO THIS):
<artifact type="application/vnd.ant.react" title="My Component">
function App() { ... }
<!DOCTYPE html>
<html>...</html>
</artifact>

Now create the React component wrapped in artifact tags:`;
  }

  // Generic prompt for other artifact types
  return `Create an artifact for: ${prompt}

IMPORTANT: Return the COMPLETE artifact wrapped in XML tags like: <artifact type="application/vnd.ant.react" title="Descriptive Title">YOUR CODE HERE</artifact>

For React artifacts: Return ONLY pure JSX/React component code. Do NOT include <!DOCTYPE>, <html>, <head>, <body> tags. The code will be transpiled by Babel, not rendered as a full HTML page.

Include the opening <artifact> tag, the complete code, and the closing </artifact> tag.`;
}

/**
 * Strip HTML document structure from React artifacts
 *
 * GLM-4.6 sometimes appends full HTML documents after the React code.
 * This causes Babel transpilation to fail with "Unexpected token '<'".
 *
 * @param code - Raw artifact code from GLM
 * @param type - Artifact type
 * @param requestId - Request ID for logging
 * @returns Cleaned artifact code
 */
function stripHtmlDocumentStructure(
  code: string,
  type: GeneratableArtifactType,
  requestId: string
): string {
  // Only strip for React artifacts
  if (type !== 'react' && !code.includes('application/vnd.ant.react')) {
    return code;
  }

  const htmlDocPattern = /<!DOCTYPE\s+html[\s\S]*$/i;
  if (htmlDocPattern.test(code)) {
    console.log(`[${requestId}] ‚ö†Ô∏è  Detected HTML document structure in React artifact - stripping...`);

    // Remove everything from <!DOCTYPE onwards
    let cleaned = code.replace(htmlDocPattern, '').trim();

    // Clean up any trailing </artifact> that might have been duplicated
    cleaned = cleaned.replace(/<\/artifact>\s*$/i, '').trim();

    // Re-add the closing tag if the artifact tag is present
    if (cleaned.includes('<artifact') && !cleaned.includes('</artifact>')) {
      cleaned = cleaned + '\n</artifact>';
    }

    console.log(`[${requestId}] ‚úÖ Stripped HTML document structure, cleaned length: ${cleaned.length}`);
    return cleaned;
  }

  return code;
}

/**
 * Execute artifact generation with validation and auto-fixing
 *
 * This is the main entry point for artifact generation logic.
 * Callers are responsible for:
 * - Authentication and authorization
 * - Rate limiting
 * - HTTP response formatting
 * - SSE streaming (if needed)
 *
 * @param params - Artifact generation parameters
 * @returns Artifact generation result
 * @throws ArtifactExecutionError on API failures
 */
export async function executeArtifactGeneration(
  params: ArtifactExecutorParams
): Promise<ArtifactExecutorResult> {
  const { type, prompt, enableThinking = true } = params;

  // SECURITY: Sanitize requestId to prevent log injection
  const requestId = sanitizeRequestId(params.requestId);

  // SECURITY: Validate inputs before expensive operations (fail-fast)
  validateParams(params, requestId);

  const startTime = Date.now();

  console.log(`[${requestId}] üé® Executing artifact generation: type=${type}, thinking=${enableThinking}`);

  // Get system prompt
  const systemPrompt = getSystemInstruction({
    currentDate: new Date().toLocaleDateString(),
  });

  // Construct user prompt based on artifact type
  const userPrompt = constructUserPrompt(prompt, type);

  // Call GLM-4.6 with retry logic
  console.log(`[${requestId}] ü§ñ Calling GLM-4.6 via Z.ai API`);
  let response;
  let retryCount;

  try {
    const result = await callGLMWithRetryTracking(systemPrompt, userPrompt, {
      temperature: 1.0, // GLM recommends 1.0 for general evaluations
      max_tokens: 16000, // Doubled from 8000 to handle complex artifacts
      requestId,
      enableThinking, // Enable reasoning for better artifact generation
    });

    response = result.response;
    retryCount = result.retryCount;
  } catch (error) {
    const err = toError(error);
    console.error(`[${requestId}] ‚ùå GLM API call failed:`, sanitizeErrorMessage(err.message));
    throw new ArtifactExecutionError(
      'Failed to call GLM API',
      ErrorCode.AI_ERROR,
      requestId,
      err
    );
  }

  // Check response status
  if (!response.ok) {
    console.error(`[${requestId}] ‚ùå GLM API returned error status: ${response.status}`);
    throw new ArtifactExecutionError(
      sanitizeErrorMessage(`GLM API error: ${response.status}`),
      ErrorCode.AI_ERROR,
      requestId
    );
  }

  // Parse response
  let data;
  try {
    data = await response.json();
  } catch (error) {
    const err = toError(error);
    console.error(`[${requestId}] ‚ùå Failed to parse GLM response:`, sanitizeErrorMessage(err.message));
    throw new ArtifactExecutionError(
      'Failed to parse GLM response JSON',
      ErrorCode.AI_ERROR,
      requestId,
      err
    );
  }

  // Log finish_reason for debugging token limit issues
  const finishReason = data?.choices?.[0]?.finish_reason;
  console.log(`[${requestId}] üìä Generation complete: finish_reason="${finishReason}"`);

  if (finishReason === 'length') {
    console.warn(`[${requestId}] ‚ö†Ô∏è  HIT TOKEN LIMIT - Response truncated at ${data?.usage?.completion_tokens || 'unknown'} output tokens`);
    console.warn(`[${requestId}] ‚ö†Ô∏è  Consider: 1) Simplifying prompt, 2) Increasing max_tokens further, 3) Using model with higher limits`);
  }

  // Extract text and reasoning from response
  const { text: rawArtifactCode, reasoning: glmReasoning } = extractTextAndReasoningFromGLM(
    data,
    requestId
  );

  if (!rawArtifactCode || rawArtifactCode.trim().length === 0) {
    console.error(`[${requestId}] ‚ùå Empty artifact code returned from API`);
    throw new ArtifactExecutionError(
      'GLM returned empty artifact code',
      ErrorCode.AI_ERROR,
      requestId
    );
  }

  // Structured reasoning parsing removed - use [STATUS:] markers instead
  const reasoningSteps = null;

  // Strip HTML document structure from React artifacts
  let artifactCode = stripHtmlDocumentStructure(rawArtifactCode, type, requestId);

  // ============================================================================
  // PRE-VALIDATION: Fix GLM syntax issues BEFORE validation
  // ============================================================================
  // This is the FIRST line of defense - catches GLM syntax bugs (const * as,
  // unquoted imports, orphaned chains) before they reach the client.
  // Prevents bundling failures and client-side rendering errors.
  const preValidation = preValidateAndFixGlmSyntax(artifactCode, requestId);
  if (preValidation.issues.length > 0) {
    console.log(`[${requestId}] üîß Pre-validation fixed ${preValidation.issues.length} GLM syntax issue(s)`);
    artifactCode = preValidation.fixed;
  }

  // ============================================================================
  // POST-GENERATION VALIDATION & AUTO-FIX
  // ============================================================================
  // Validate artifact code for common issues:
  // - Reserved keywords (eval, arguments, etc.)
  // - Invalid imports (@/components/ui/*)
  // - Immutability violations (array mutations)
  const validation = validateArtifactCode(artifactCode, type);
  let autoFixed = false;

  if (!validation.valid && validation.canAutoFix) {
    console.log(`[${requestId}] ‚ö†Ô∏è  Validation issues detected, attempting auto-fix...`);

    // Log specific issue types
    const issueTypes = {
      reserved: validation.issues.filter((i) => i.message.includes('Reserved keyword')).length,
      imports: validation.issues.filter((i) => i.message.includes('import')).length,
      immutability: validation.issues.filter(
        (i) => i.message.includes('mutate') || i.message.includes('Direct array assignment')
      ).length,
    };

    if (issueTypes.reserved > 0) {
      console.log(`[${requestId}] üîß Reserved keyword issues: ${issueTypes.reserved}`);
    }
    if (issueTypes.imports > 0) {
      console.log(`[${requestId}] üîß Import issues: ${issueTypes.imports}`);
    }
    if (issueTypes.immutability > 0) {
      console.log(`[${requestId}] üîß Immutability violations: ${issueTypes.immutability}`);
    }

    const { fixed, changes } = autoFixArtifactCode(artifactCode);

    if (changes.length > 0) {
      console.log(`[${requestId}] ‚úÖ Auto-fixed ${changes.length} issue(s):`, changes);
      artifactCode = fixed;
      autoFixed = true;

      // Re-validate after fixes
      const revalidation = validateArtifactCode(artifactCode, type);
      if (!revalidation.valid) {
        console.warn(`[${requestId}] ‚ö†Ô∏è  Some issues remain after auto-fix:`, revalidation.issues);
      } else {
        console.log(`[${requestId}] ‚úÖ All issues resolved after auto-fix`);
      }
    }
  } else if (!validation.valid) {
    console.warn(`[${requestId}] ‚ö†Ô∏è  Validation issues detected (cannot auto-fix):`, validation.issues);
  } else {
    console.log(`[${requestId}] ‚úÖ Artifact code validated successfully (no issues)`);
  }

  // Extract token usage for cost tracking
  const tokenUsage = extractGLMTokenUsage(data);
  const estimatedCost = calculateGLMCost(tokenUsage.inputTokens, tokenUsage.outputTokens);

  console.log(`[${requestId}] üí∞ Token usage:`, {
    input: tokenUsage.inputTokens,
    output: tokenUsage.outputTokens,
    total: tokenUsage.totalTokens,
    estimatedCost: `$${estimatedCost.toFixed(4)}`,
  });

  // Calculate total latency
  const latencyMs = Date.now() - startTime;

  console.log(`[${requestId}] ‚úÖ Artifact generation complete: ${artifactCode.length} chars in ${latencyMs}ms (${retryCount} retries)`);

  return {
    artifactCode,
    reasoning: glmReasoning,
    reasoningSteps,
    tokenUsage,
    estimatedCost,
    validation: {
      valid: validation.valid,
      autoFixed,
      issueCount: validation.issues.length,
    },
    latencyMs,
  };
}
