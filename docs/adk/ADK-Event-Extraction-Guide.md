# ADK Event Content Extraction Guide

## Critical: Why This Guide Exists

**This guide exists because missing functionResponse extraction is a recurring bug that breaks core functionality.**

Research plans generated by the `plan_generator` agent are delivered via `functionResponse` parts, NOT `text` parts. If you only extract from `text`, research plans become invisible to users, breaking the entire research workflow.

##⚠️ The #1 Mistake

```python
# ❌ WRONG - Only extracts text, misses functionResponse
for part in parts:
    text = part.get("text")
    if text:
        accumulated_content.append(text)
```

**What breaks**: Research plans, agent tool outputs, analysis results - anything from `AgentTool()` wrapped functions.

## ✅ Correct Implementation

```python
# ✅ CORRECT - Extracts from BOTH text and functionResponse
for part in parts:
    # Extract regular text streaming
    text = part.get("text")
    if text:
        accumulated_content.append(text)

    # Extract agent tool outputs (CRITICAL!)
    function_response = part.get("functionResponse")
    if function_response and isinstance(function_response, dict):
        response_data = function_response.get("response", {})
        result_text = response_data.get("result")
        if result_text:
            accumulated_content.append(result_text)
```

---

## Table of Contents

1. [Understanding ADK Event Structure](#understanding-adk-event-structure)
2. [Content Types in parts[]](#content-types-in-parts)
3. [Complete Extraction Pattern](#complete-extraction-pattern)
4. [Real-World Examples](#real-world-examples)
5. [Testing for Regressions](#testing-for-regressions)
6. [Common Pitfalls](#common-pitfalls)

---

## Understanding ADK Event Structure

### Full Event Schema

```typescript
interface ADKEvent {
  content: {
    parts: Array<
      | { text: string }                    // Model streaming output
      | { functionCall: FunctionCall }      // Tool invocation request
      | { functionResponse: FunctionResponse } // Tool result (CRITICAL!)
      | { thoughtSignature: ThoughtProcess }  // Model reasoning
    >;
    role: "model" | "user";
  };
  author: string;  // Agent identifier
  usageMetadata?: TokenUsage;
}
```

### Why parts[] is Polymorphic

ADK agents communicate through a multi-turn conversation that includes:
- **Model output**: Streamed text responses (`text`)
- **Tool calls**: Agent invoking sub-agents or tools (`functionCall`)
- **Tool results**: Output from those invocations (`functionResponse`) ⚠️ **THIS IS WHERE RESEARCH PLANS LIVE**
- **Reasoning**: Internal thought process (`thoughtSignature`)

**The Critical Part**: When `plan_generator` or other `AgentTool()` wrapped functions execute, their output comes back as `functionResponse`, NOT `text`.

---

## Content Types in parts[]

### 1. text - Direct Model Output

```json
{
  "content": {
    "parts": [{
      "text": "I'll help you research that topic..."
    }],
    "role": "model"
  },
  "author": "interactive_planner_agent"
}
```

**Use Case**: Streaming responses, explanations, status updates

### 2. functionCall - Tool Invocation

```json
{
  "content": {
    "parts": [{
      "functionCall": {
        "id": "adk-abc123",
        "name": "plan_generator",
        "args": {
          "query": "explain quantum computing"
        }
      }
    }],
    "role": "model"
  },
  "author": "interactive_planner_agent"
}
```

**Use Case**: Agent requesting a tool/sub-agent to execute

### 3. functionResponse - Tool Result ⚠️ **CRITICAL**

```json
{
  "content": {
    "parts": [{
      "functionResponse": {
        "id": "adk-abc123",
        "name": "plan_generator",
        "response": {
          "result": "*   **[RESEARCH]** Analyze quantum mechanics principles...\n*   **[RESEARCH]** Investigate quantum computer architecture...\n*   **[DELIVERABLE]** Compile comprehensive summary..."
        }
      }
    }],
    "role": "model"
  },
  "author": "interactive_planner_agent"
}
```

**Use Case**: Results from `AgentTool()` wrapped functions - **THIS IS WHERE RESEARCH PLANS COME FROM**

### 4. thoughtSignature - Model Reasoning

```json
{
  "content": {
    "parts": [{
      "thoughtSignature": {
        "thinking": "The user wants to understand quantum computing...",
        "step": "analysis"
      }
    }],
    "role": "model"
  },
  "author": "interactive_planner_agent"
}
```

**Use Case**: Internal reasoning, debugging AI thought process

---

## Complete Extraction Pattern

### Full Implementation with All Part Types

```python
from datetime import datetime
import json
import logging

logger = logging.getLogger(__name__)

async def extract_and_broadcast_adk_content(
    session_id: str,
    data: dict,
    accumulated_content: list[str],
    broadcaster
):
    """
    Extract content from ADK events and broadcast via SSE.

    CRITICAL: Must handle ALL part types to avoid missing content.

    Args:
        session_id: Session identifier
        data: Parsed ADK event JSON
        accumulated_content: List to accumulate extracted text
        broadcaster: SSE broadcaster instance
    """
    content_obj = data.get("content")
    if not content_obj or not isinstance(content_obj, dict):
        return

    parts = content_obj.get("parts", [])
    content_extracted = False

    for part in parts:
        if not isinstance(part, dict):
            continue

        # 1. Extract direct text output
        text = part.get("text")
        if text:
            accumulated_content.append(text)
            content_extracted = True
            logger.debug(f"Extracted text: {len(text)} chars")

        # 2. Extract functionResponse (CRITICAL for agent tool outputs)
        # This is where plan_generator, research agents, and other
        # AgentTool() wrapped functions return their results
        function_response = part.get("functionResponse")
        if function_response and isinstance(function_response, dict):
            tool_name = function_response.get("name", "unknown")
            response_data = function_response.get("response", {})
            result_text = response_data.get("result")

            if result_text:
                accumulated_content.append(result_text)
                content_extracted = True
                logger.info(
                    f"Extracted functionResponse from {tool_name}: "
                    f"{len(result_text)} chars"
                )
            else:
                logger.warning(
                    f"functionResponse from {tool_name} has no result field"
                )

        # 3. Log functionCall for debugging (don't extract content)
        function_call = part.get("functionCall")
        if function_call:
            tool_name = function_call.get("name", "unknown")
            logger.debug(f"Tool invocation: {tool_name}")

        # 4. Log thoughtSignature for debugging (optional to extract)
        thought = part.get("thoughtSignature")
        if thought:
            logger.debug(f"Model thinking: {str(thought)[:100]}")

    # Broadcast accumulated content if any was extracted
    if content_extracted and accumulated_content:
        await broadcaster.broadcast_event(session_id, {
            "type": "research_update",
            "data": {
                "content": "".join(accumulated_content),
                "timestamp": datetime.now().isoformat()
            }
        })
        logger.info(
            f"Broadcasted research_update for session {session_id}, "
            f"total content: {len(''.join(accumulated_content))} chars"
        )
```

### Minimal Safe Implementation

```python
# Minimum viable extraction - handles the two critical types
for part in content.get("parts", []):
    # Text parts - model streaming
    if "text" in part:
        accumulated_content.append(part["text"])

    # FunctionResponse parts - agent tool outputs (CRITICAL!)
    if "functionResponse" in part:
        result = part["functionResponse"].get("response", {}).get("result")
        if result:
            accumulated_content.append(result)
```

---

## Real-World Examples

### Example 1: plan_generator Response

**Agent Configuration** (`agents/vana/agent.py`):
```python
from google.adk.agents import LlmAgent, AgentTool

# plan_generator is wrapped in AgentTool
interactive_planner_agent = LlmAgent(
    name="interactive_planner_agent",
    tools=[AgentTool(plan_generator)],  # ← Outputs via functionResponse!
    ...
)
```

**ADK Event Received**:
```json
{
  "content": {
    "parts": [{
      "functionResponse": {
        "id": "adk-12345",
        "name": "plan_generator",
        "response": {
          "result": "*   **[RESEARCH]** Analyze fundamental principles\n*   **[RESEARCH]** Investigate core components\n*   **[DELIVERABLE]** Compile comprehensive summary"
        }
      }
    }],
    "role": "model"
  },
  "author": "interactive_planner_agent"
}
```

**Extraction Result**:
```python
# With correct implementation
result_text = part["functionResponse"]["response"]["result"]
# result_text = "*   **[RESEARCH]** Analyze fundamental principles\n..."

# ❌ With text-only extraction
# result_text = None  ← BUG: Research plan disappears!
```

### Example 2: Mixed Content Stream

```python
# ADK sends multiple events in sequence:

# Event 1: Model introduces task
{
  "content": {
    "parts": [{"text": "I'll create a research plan for you."}]
  }
}

# Event 2: Model calls plan_generator tool
{
  "content": {
    "parts": [{
      "functionCall": {
        "name": "plan_generator",
        "args": {"query": "quantum computing"}
      }
    }]
  }
}

# Event 3: plan_generator returns result (CRITICAL!)
{
  "content": {
    "parts": [{
      "functionResponse": {
        "name": "plan_generator",
        "response": {
          "result": "*   **[RESEARCH]** Quantum mechanics principles\n..."
        }
      }
    }]
  }
}

# Event 4: Model asks for approval
{
  "content": {
    "parts": [{"text": "Does this research plan look good?"}]
  }
}

# Final accumulated_content (if ALL events processed correctly):
# [
#   "I'll create a research plan for you.",
#   "*   **[RESEARCH]** Quantum mechanics principles\n...",
#   "Does this research plan look good?"
# ]
```

---

## Testing for Regressions

### Unit Test Template

```python
import pytest
import json
from app.routes.adk_routes import extract_and_broadcast_adk_content

@pytest.mark.asyncio
async def test_function_response_extraction():
    """
    REGRESSION TEST: Ensure functionResponse content is extracted.

    This test prevents the bug where research plans disappear
    because only text parts were being extracted.
    """
    # Mock ADK event with functionResponse
    adk_event = {
        "content": {
            "parts": [{
                "functionResponse": {
                    "id": "test-123",
                    "name": "plan_generator",
                    "response": {
                        "result": "**[RESEARCH]** Test research plan"
                    }
                }
            }],
            "role": "model"
        },
        "author": "interactive_planner_agent"
    }

    accumulated_content = []
    mock_broadcaster = MockBroadcaster()

    await extract_and_broadcast_adk_content(
        session_id="test_session",
        data=adk_event,
        accumulated_content=accumulated_content,
        broadcaster=mock_broadcaster
    )

    # CRITICAL ASSERTION: functionResponse content must be extracted
    assert len(accumulated_content) == 1
    assert "Test research plan" in accumulated_content[0]
    assert mock_broadcaster.broadcast_called

@pytest.mark.asyncio
async def test_mixed_content_extraction():
    """Test extraction from both text and functionResponse parts."""
    adk_event = {
        "content": {
            "parts": [
                {"text": "Creating plan..."},
                {
                    "functionResponse": {
                        "name": "plan_generator",
                        "response": {"result": "**[RESEARCH]** Plan content"}
                    }
                },
                {"text": "Does this look good?"}
            ],
            "role": "model"
        }
    }

    accumulated_content = []
    mock_broadcaster = MockBroadcaster()

    await extract_and_broadcast_adk_content(
        session_id="test_session",
        data=adk_event,
        accumulated_content=accumulated_content,
        broadcaster=mock_broadcaster
    )

    # Should extract ALL three pieces of content
    assert len(accumulated_content) == 3
    assert "Creating plan..." in accumulated_content[0]
    assert "Plan content" in accumulated_content[1]
    assert "Does this look good?" in accumulated_content[2]
```

### Integration Test

```bash
# Test with real ADK service
curl -X POST http://localhost:8000/apps/vana/users/default/sessions/test_session/run \
  -H "Content-Type: application/json" \
  -d '{"query": "test query"}' &

# Connect to SSE stream
curl -N http://localhost:8000/apps/vana/users/default/sessions/test_session/run

# Verify research_update events contain research plan content
# Expected: Events with type="research_update" containing [RESEARCH] items
```

---

## Common Pitfalls

### Pitfall 1: Only Checking for "text"

```python
# ❌ WRONG
if "text" in part:
    content.append(part["text"])
# Result: Misses all functionResponse content
```

**Fix**: Always check BOTH `text` AND `functionResponse`

### Pitfall 2: Not Validating Response Structure

```python
# ❌ WRONG - Assumes structure exists
result = part["functionResponse"]["response"]["result"]
# Result: KeyError if structure differs
```

**Fix**: Use defensive gets:
```python
# ✅ CORRECT
function_response = part.get("functionResponse")
if function_response and isinstance(function_response, dict):
    response_data = function_response.get("response", {})
    result_text = response_data.get("result")
    if result_text:
        content.append(result_text)
```

### Pitfall 3: Broadcasting Too Early

```python
# ❌ WRONG - Broadcasts inside part loop
for part in parts:
    if "text" in part:
        accumulated_content.append(part["text"])
        await broadcaster.broadcast_event(...)  # ← Broadcasts per-part!
```

**Fix**: Accumulate first, broadcast once:
```python
# ✅ CORRECT
for part in parts:
    # Extract all content...

# Broadcast once after all parts processed
if accumulated_content:
    await broadcaster.broadcast_event(...)
```

### Pitfall 4: Ignoring Event Types

```python
# ❌ WRONG - Processes all events the same way
for line in response.aiter_lines():
    data = json.loads(line[6:])
    # Always extracts content, even from metadata events
```

**Fix**: Check if event has content:
```python
# ✅ CORRECT
content_obj = data.get("content")
if content_obj and isinstance(content_obj, dict):
    # Process content parts...
else:
    # Log non-content event for debugging
    logger.debug(f"Non-content event: {data.get('id')}")
```

---

## Quick Reference

### Checklist for ADK Event Processing

- [ ] Handle `text` parts for model streaming
- [ ] Handle `functionResponse` parts for agent tool outputs ⚠️ **CRITICAL**
- [ ] Validate nested structure with `.get()`
- [ ] Accumulate content before broadcasting
- [ ] Log extraction for debugging
- [ ] Test with real plan_generator responses
- [ ] Add regression tests

### Code Snippet for Copy-Paste

```python
# Safe ADK content extraction (copy this!)
content_obj = data.get("content")
if content_obj and isinstance(content_obj, dict):
    parts = content_obj.get("parts", [])
    for part in parts:
        if isinstance(part, dict):
            # Extract text
            text = part.get("text")
            if text:
                accumulated_content.append(text)

            # Extract functionResponse (CRITICAL!)
            function_response = part.get("functionResponse")
            if function_response and isinstance(function_response, dict):
                result = function_response.get("response", {}).get("result")
                if result:
                    accumulated_content.append(result)
```

---

## Further Reading

- [ADK API Reference](../adk-api-reference.md) - Complete API documentation
- [SSE Implementation Guide](../sse/SSE-Implementation-Guide.md) - SSE patterns
- [ADK Samples](https://github.com/google/adk-samples) - Official Google examples
- [Agent Overview](https://googlecloudplatform.github.io/agent-starter-pack/agents/overview.html) - ADK agent concepts

---

**Remember**: If research plans aren't showing up, 99% of the time it's because `functionResponse` extraction is missing or broken. Always extract from BOTH `text` AND `functionResponse` parts!
