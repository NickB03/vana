[
  {
    "id": "adk_example_1-basic-agent",
    "content": "# Basic ADK Agent Example\n\n## What is an ADK Agent?\n\nThe `LlmAgent` (often aliased simply as `Agent`) is a core component in ADK that acts as the \"thinking\" part of your application. It leverages the power of a Large Language Model (LLM) for:\n- Reasoning\n- Understanding natural language\n- Making decisions\n- Generating responses\n- Interacting with tools\n\nUnlike deterministic workflow agents that follow predefined paths, an `LlmAgent`'s behavior is non-deterministic. It uses the LLM to interpret instructions and context, deciding dynamically how to proceed, which tools to use (if any), or whether to transfer control to another agent.\n\n## Required Agent Structure\n\nFor ADK to discover and run your agents properly (especially with `adk web`), your project must follow a specific structure:\n\n```\nparent_folder/\n    agent_folder/         # This is your agent's package directory\n        __init__.py       # Must import agent.py\n        agent.py          # Must define root_agent\n        .env              # Environment variables\n```\n\n### Essential Components:\n\n1. **`__init__.py`**\n   - Must import the agent module: `from . import agent`\n   - This makes your agent discoverable by ADK\n\n2. **`agent.py`**\n   - Must define a variable named `root_agent`\n   - This is the entry point that ADK uses to find your agent\n\n3. **Command Location**\n   - Always run `adk` commands from the parent directory, not from inside the agent directory\n   - Example: Run `adk web` from the parent folder that contains your agent folder\n\nThis structure ensures that ADK can automatically discover and load your agent when running commands like `adk web` or `adk run`.\n\n## Key Components\n\n### 1. Identity (`name` and `description`)\n- **name** (Required): A unique string identifier for your agent\n- **description** (Optional, but recommended): A concise summary of the agent's capabilities. Used for other agents to determine if they should route a task to this agent.\n\n### 2. Model (`model`)\n- Specifies which LLM powers the agent (e.g., \"gemini-2.0-flash\")\n- Affects the agent's capabilities, cost, and performance\n\n### 3. Instructions (`instruction`)\nThe most critical parameter for shaping your agent's behavior. It defines:\n- Core task or goal\n- Personality or persona\n- Behavioral constraints\n- How to use available tools\n- Desired output format\n\n### 4. Tools (`tools`)\nOptional capabilities beyond the LLM's built-in knowledge, allowing the agent to:\n- Interact with external systems\n- Perform calculations\n- Fetch real-time data\n- Execute specific actions\n\n## Getting Started\n\nThis example uses the same virtual environment created in the root directory. Make sure you have:\n\n1. Activated the virtual environment from the root directory:\n```bash\n# macOS/Linux:\nsource ../.venv/bin/activate\n# Windows CMD:\n..\\.venv\\Scripts\\activate.bat\n# Windows PowerShell:\n..\\.venv\\Scripts\\Activate.ps1\n```\n\n2. Set up your API key:\n   - Rename `.env.example` to `.env` in the greeting_agent folder\n   - Add your Google API key to the `GOOGLE_API_KEY` variable in the `.env` file\n\n## Running the Example\n\nTo run this basic agent example, you'll use the ADK CLI tool which provides several ways to interact with your agent:\n\n1. Navigate to the 1-basic-agent directory containing your agent folder.\n2. Start the interactive web UI:\n```bash\nadk web\n```\n\n3. Access the web UI by opening the URL shown in your terminal (typically http://localhost:8000)\n\n4. Select your agent from the dropdown menu in the top-left corner of the UI\n\n5. Start chatting with your agent in the textbox at the bottom of the screen\n\n### Troubleshooting\n\nIf your agent doesn't appear in the dropdown menu:\n- Make sure you're running `adk web` from the parent directory (1-basic-agent), not from inside the agent directory\n- Check that your `__init__.py` properly imports the agent module\n- Verify that `agent.py` defines a variable named `root_agent`\n\n### Alternative Run Methods\n\nThe ADK CLI tool provides several options:\n\n- **`adk web`**: Launches an interactive web UI for testing your agent with a chat interface\n- **`adk run [agent_name]`**: Runs your agent directly in the terminal\n- **`adk api_server`**: Starts a FastAPI server to test API requests to your agent\n\n### Example Prompts to Try\n\n- \"How do you say hello in Spanish?\"\n- \"What's a formal greeting in Japanese?\"\n- \"Tell me how to greet someone in French\"\n\nYou can exit the conversation or stop the server by pressing `Ctrl+C` in your terminal.\n\nThis example demonstrates a simple agent that responds to greeting-related queries, showing the fundamentals of agent creation with ADK.\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "1-basic-agent",
      "type": "documentation",
      "file": "README.md",
      "indexed_at": "2025-07-22T14:24:19.159671"
    },
    "displayName": "ADK Example: 1-basic-agent (documentation)"
  },
  {
    "id": "adk_code_5338647d",
    "content": "# ADK Example: 1-basic-agent\n# File: 1-basic-agent/greeting_agent/agent.py\n\nfrom google.adk.agents import Agent\n\nroot_agent = Agent(\n    name=\"greeting_agent\",\n    # https://ai.google.dev/gemini-api/docs/models\n    model=\"gemini-2.0-flash\",\n    description=\"Greeting agent\",\n    instruction=\"\"\"\n    You are a helpful assistant that greets the user. \n    Ask for the user's name and greet them by name.\n    \"\"\",\n)\n\n\n# This code demonstrates:\n# - ADK patterns for basic agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "1-basic-agent",
      "type": "code",
      "file": "1-basic-agent/greeting_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.159972"
    },
    "displayName": "ADK Example: 1-basic-agent (code)"
  },
  {
    "id": "adk_example_10-sequential-agent",
    "content": "# Sequential Agents in ADK\n\nThis example demonstrates how to implement a Sequential Agent in the Agent Development Kit (ADK). The main agent in this example, `lead_qualification_agent`, is a Sequential Agent that executes sub-agents in a predefined order, with each agent's output feeding into the next agent in the sequence.\n\n## What are Sequential Agents?\n\nSequential Agents are workflow agents in ADK that:\n\n1. **Execute in a Fixed Order**: Sub-agents run one after another in the exact sequence they are specified\n2. **Pass Data Between Agents**: Using state management to pass information from one sub-agent to the next\n3. **Create Processing Pipelines**: Perfect for scenarios where each step depends on the previous step's output\n\nUse Sequential Agents when you need a deterministic, step-by-step workflow where the execution order matters.\n\n## Lead Qualification Pipeline Example\n\nIn this example, we've created `lead_qualification_agent` as a Sequential Agent that implements a lead qualification pipeline for sales teams. This Sequential Agent orchestrates three specialized sub-agents:\n\n1. **Lead Validator Agent**: Checks if the lead information is complete enough for qualification\n   - Validates for required information like contact details and interest\n   - Outputs a simple \"valid\" or \"invalid\" with a reason\n\n2. **Lead Scorer Agent**: Scores valid leads on a scale of 1-10\n   - Analyzes factors like urgency, decision-making authority, budget, and timeline\n   - Provides a numeric score with a brief justification\n\n3. **Action Recommender Agent**: Suggests next steps based on the validation and score\n   - For invalid leads: Recommends what information to gather\n   - For low-scoring leads (1-3): Suggests nurturing actions\n   - For medium-scoring leads (4-7): Suggests qualifying actions\n   - For high-scoring leads (8-10): Suggests sales actions\n\n### How It Works\n\nThe `lead_qualification_agent` Sequential Agent orchestrates this process by:\n\n1. Running the Validator first to determine if the lead is complete\n2. Running the Scorer next (which can access validation results via state)\n3. Running the Recommender last (which can access both validation and scoring results)\n\nThe output of each sub-agent is stored in the session state using the `output_key` parameter:\n- `validation_status`\n- `lead_score`\n- `action_recommendation`\n\n## Project Structure\n\n```\n9-sequential-agent/\n│\n├── lead_qualification_agent/       # Main Sequential Agent package\n│   ├── __init__.py                 # Package initialization\n│   ├── agent.py                    # Sequential Agent definition (root_agent)\n│   │\n│   └── subagents/                  # Sub-agents folder\n│       ├── __init__.py             # Sub-agents initialization\n│       │\n│       ├── validator/              # Lead validation agent\n│       │   ├── __init__.py\n│       │   └── agent.py\n│       │\n│       ├── scorer/                 # Lead scoring agent\n│       │   ├── __init__.py\n│       │   └── agent.py\n│       │\n│       └── recommender/            # Action recommendation agent\n│           ├── __init__.py\n│           └── agent.py\n│\n├── .env.example                    # Environment variables example\n└── README.md                       # This documentation\n```\n\n## Getting Started\n\n### Setup\n\n1. Activate the virtual environment from the root directory:\n```bash\n# macOS/Linux:\nsource ../.venv/bin/activate\n# Windows CMD:\n..\\.venv\\Scripts\\activate.bat\n# Windows PowerShell:\n..\\.venv\\Scripts\\Activate.ps1\n```\n\n2. Copy the `.env.example` file to `.env` and add your Google API key:\n```\nGOOGLE_API_KEY=your_api_key_here\n```\n\n### Running the Example\n\n```bash\ncd 9-sequential-agent\nadk web\n```\n\nThen select \"lead_qualification_agent\" from the dropdown menu in the web UI.\n\n## Example Interactions\n\nTry these example interactions:\n\n### Qualified Lead Example:\n```\nLead Information:\nName: Sarah Johnson\nEmail: sarah.j@techinnovate.com\nPhone: 555-123-4567\nCompany: Tech Innovate Solutions\nPosition: CTO\nInterest: Looking for an AI solution to automate customer support\nBudget: $50K-100K available for the right solution\nTimeline: Hoping to implement within next quarter\nNotes: Currently using a competitor's product but unhappy with performance\n```\n\n### Unqualified Lead Example:\n```\nLead Information:\nName: John Doe\nEmail: john@gmail.com\nInterest: Something with AI maybe\nNotes: Met at conference, seemed interested but was vague about needs\n```\n\n## How Sequential Agents Compare to Other Workflow Agents\n\nADK offers different types of workflow agents for different needs:\n\n- **Sequential Agents**: For strict, ordered execution (like this example)\n- **Loop Agents**: For repeated execution of sub-agents based on conditions\n- **Parallel Agents**: For concurrent execution of independent sub-agents\n\n## Additional Resources\n\n- [ADK Sequential Agents Documentation](https://google.github.io/adk-docs/agents/workflow-agents/sequential-agents/)\n- [Full Code Development Pipeline Example](https://google.github.io/adk-docs/agents/workflow-agents/sequential-agents/#full-example-code-development-pipeline) \n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "10-sequential-agent",
      "type": "documentation",
      "file": "README.md",
      "indexed_at": "2025-07-22T14:24:19.160148"
    },
    "displayName": "ADK Example: 10-sequential-agent (documentation)"
  },
  {
    "id": "adk_code_c0552164",
    "content": "# ADK Example: 10-sequential-agent\n# File: 10-sequential-agent/lead_qualification_agent/agent.py\n\n\"\"\"\nSequential Agent with a Minimal Callback\n\nThis example demonstrates a lead qualification pipeline with a minimal\nbefore_agent_callback that only initializes state once at the beginning.\n\"\"\"\n\nfrom google.adk.agents import SequentialAgent\n\nfrom .subagents.recommender import action_recommender_agent\nfrom .subagents.scorer import lead_scorer_agent\n\n# Import the subagents\nfrom .subagents.validator import lead_validator_agent\n\n# Create the sequential agent with minimal callback\nroot_agent = SequentialAgent(\n    name=\"LeadQualificationPipeline\",\n    sub_agents=[lead_validator_agent, lead_scorer_agent, action_recommender_agent],\n    description=\"A pipeline that validates, scores, and recommends actions for sales leads\",\n)\n\n\n# This code demonstrates:\n# - ADK patterns for sequential agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "10-sequential-agent",
      "type": "code",
      "file": "10-sequential-agent/lead_qualification_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.160536"
    },
    "displayName": "ADK Example: 10-sequential-agent (code)"
  },
  {
    "id": "adk_code_1b209380",
    "content": "# ADK Example: 10-sequential-agent\n# File: 10-sequential-agent/lead_qualification_agent/subagents/validator/agent.py\n\n\"\"\"\nLead Validator Agent\n\nThis agent is responsible for validating if a lead has all the necessary information\nfor qualification.\n\"\"\"\n\nfrom google.adk.agents import LlmAgent\n\n# --- Constants ---\nGEMINI_MODEL = \"gemini-2.0-flash\"\n\n# Create the validator agent\nlead_validator_agent = LlmAgent(\n    name=\"LeadValidatorAgent\",\n    model=GEMINI_MODEL,\n    instruction=\"\"\"You are a Lead Validation AI.\n    \n    Examine the lead information provided by the user and determine if it's complete enough for qualification.\n    A complete lead should include:\n    - Contact information (name, email or phone)\n    - Some indication of interest or need\n    - Company or context information if applicable\n    \n    Output ONLY 'valid' or 'invalid' with a single reason if invalid.\n    \n    Example valid output: 'valid'\n    Example invalid output: 'invalid: missing contact information'\n    \"\"\",\n    description=\"Validates lead information for completeness.\",\n    output_key=\"validation_status\",\n)\n\n\n# This code demonstrates:\n# - ADK patterns for sequential agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "10-sequential-agent",
      "type": "code",
      "file": "10-sequential-agent/lead_qualification_agent/subagents/validator/agent.py",
      "indexed_at": "2025-07-22T14:24:19.160829"
    },
    "displayName": "ADK Example: 10-sequential-agent (code)"
  },
  {
    "id": "adk_code_0eb35440",
    "content": "# ADK Example: 10-sequential-agent\n# File: 10-sequential-agent/lead_qualification_agent/subagents/scorer/agent.py\n\n\"\"\"\nLead Scorer Agent\n\nThis agent is responsible for scoring a lead's qualification level\nbased on various criteria.\n\"\"\"\n\nfrom google.adk.agents import LlmAgent\n\n# --- Constants ---\nGEMINI_MODEL = \"gemini-2.0-flash\"\n\n# Create the scorer agent\nlead_scorer_agent = LlmAgent(\n    name=\"LeadScorerAgent\",\n    model=GEMINI_MODEL,\n    instruction=\"\"\"You are a Lead Scoring AI.\n    \n    Analyze the lead information and assign a qualification score from 1-10 based on:\n    - Expressed need (urgency/clarity of problem)\n    - Decision-making authority\n    - Budget indicators\n    - Timeline indicators\n    \n    Output ONLY a numeric score and ONE sentence justification.\n    \n    Example output: '8: Decision maker with clear budget and immediate need'\n    Example output: '3: Vague interest with no timeline or budget mentioned'\n    \"\"\",\n    description=\"Scores qualified leads on a scale of 1-10.\",\n    output_key=\"lead_score\",\n)\n\n\n# This code demonstrates:\n# - ADK patterns for sequential agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "10-sequential-agent",
      "type": "code",
      "file": "10-sequential-agent/lead_qualification_agent/subagents/scorer/agent.py",
      "indexed_at": "2025-07-22T14:24:19.161019"
    },
    "displayName": "ADK Example: 10-sequential-agent (code)"
  },
  {
    "id": "adk_code_919a41a8",
    "content": "# ADK Example: 10-sequential-agent\n# File: 10-sequential-agent/lead_qualification_agent/subagents/recommender/agent.py\n\n\"\"\"\nAction Recommender Agent\n\nThis agent is responsible for recommending appropriate next actions\nbased on the lead validation and scoring results.\n\"\"\"\n\nfrom google.adk.agents import LlmAgent\n\n# --- Constants ---\nGEMINI_MODEL = \"gemini-2.0-flash\"\n\n# Create the recommender agent\naction_recommender_agent = LlmAgent(\n    name=\"ActionRecommenderAgent\",\n    model=GEMINI_MODEL,\n    instruction=\"\"\"You are an Action Recommendation AI.\n    \n    Based on the lead information and scoring:\n    \n    - For invalid leads: Suggest what additional information is needed\n    - For leads scored 1-3: Suggest nurturing actions (educational content, etc.)\n    - For leads scored 4-7: Suggest qualifying actions (discovery call, needs assessment)\n    - For leads scored 8-10: Suggest sales actions (demo, proposal, etc.)\n    \n    Format your response as a complete recommendation to the sales team.\n    \n    Lead Score:\n    {lead_score}\n\n    Lead Validation Status:\n    {validation_status}\n    \"\"\",\n    description=\"Recommends next actions based on lead qualification.\",\n    output_key=\"action_recommendation\",\n)\n\n\n# This code demonstrates:\n# - ADK patterns for sequential agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "10-sequential-agent",
      "type": "code",
      "file": "10-sequential-agent/lead_qualification_agent/subagents/recommender/agent.py",
      "indexed_at": "2025-07-22T14:24:19.161301"
    },
    "displayName": "ADK Example: 10-sequential-agent (code)"
  },
  {
    "id": "adk_example_11-parallel-agent",
    "content": "# Parallel Agents in ADK\n\nThis example demonstrates how to implement a Parallel Agent in the Agent Development Kit (ADK). The main agent in this example, `system_monitor_agent`, uses a Parallel Agent to gather system information concurrently and then synthesizes it into a comprehensive system health report.\n\n## What are Parallel Agents?\n\nParallel Agents are workflow agents in ADK that:\n\n1. **Execute Concurrently**: Sub-agents run simultaneously rather than sequentially\n2. **Operate Independently**: Each sub-agent works independently without sharing state during execution\n3. **Improve Performance**: Dramatically speed up workflows where tasks can be performed in parallel\n\nUse Parallel Agents when you need to execute multiple independent tasks efficiently and time is a critical factor.\n\n## System Monitoring Example\n\nIn this example, we've created a system monitoring application that uses a Parallel Agent to gather system information. The workflow consists of:\n\n1. **Parallel System Information Gathering**: Using a `ParallelAgent` to concurrently collect data about:\n   - CPU usage and statistics\n   - Memory utilization\n   - Disk space and usage\n\n2. **Sequential Report Synthesis**: After parallel data collection, a synthesizer agent combines all information into a comprehensive report\n\n### Sub-Agents\n\n1. **CPU Info Agent**: Collects and analyzes CPU information\n   - Retrieves core counts, usage statistics, and performance metrics\n   - Identifies potential performance issues (high CPU usage)\n\n2. **Memory Info Agent**: Gathers memory usage information\n   - Collects total, used, and available memory\n   - Analyzes memory pressure and swap usage\n\n3. **Disk Info Agent**: Analyzes disk space and usage\n   - Reports on total, used, and free disk space\n   - Identifies disks that are running low on space\n\n4. **System Report Synthesizer**: Combines all gathered information into a comprehensive system health report\n   - Creates an executive summary of system health\n   - Organizes component-specific information into sections\n   - Provides recommendations based on system metrics\n\n### How It Works\n\nThe architecture combines both parallel and sequential workflow patterns:\n\n1. First, the `system_info_gatherer` Parallel Agent runs all three information agents concurrently\n2. Then, the `system_report_synthesizer` uses the collected data to generate a final report\n\nThis hybrid approach demonstrates how to combine workflow agent types for optimal performance and logical flow.\n\n## Project Structure\n\n```\n10-parallel-agent/\n│\n├── system_monitor_agent/          # Main System Monitor Agent package\n│   ├── __init__.py                # Package initialization\n│   ├── agent.py                   # Agent definitions (root_agent)\n│   │\n│   └── subagents/                 # Sub-agents folder\n│       ├── __init__.py            # Sub-agents initialization\n│       │\n│       ├── cpu_info_agent/        # CPU information agent\n│       │   ├── __init__.py\n│       │   ├── agent.py\n│       │   └── tools.py           # CPU info collection tools\n│       │\n│       ├── memory_info_agent/     # Memory information agent\n│       │   ├── __init__.py\n│       │   ├── agent.py\n│       │   └── tools.py           # Memory info collection tools\n│       │\n│       ├── disk_info_agent/       # Disk information agent\n│       │   ├── __init__.py\n│       │   ├── agent.py\n│       │   └── tools.py           # Disk info collection tools\n│       │\n│       └── synthesizer_agent/     # Report synthesizing agent\n│           ├── __init__.py\n│           └── agent.py\n│\n├── .env.example                   # Environment variables example\n└── README.md                      # This documentation\n```\n\n## Getting Started\n\n### Setup\n\n1. Activate the virtual environment from the root directory:\n```bash\n# macOS/Linux:\nsource ../.venv/bin/activate\n# Windows CMD:\n..\\.venv\\Scripts\\activate.bat\n# Windows PowerShell:\n..\\.venv\\Scripts\\Activate.ps1\n```\n\n2. Copy the `.env.example` file to `.env` and add your Google API key:\n```\nGOOGLE_API_KEY=your_api_key_here\n```\n\n### Running the Example\n\n```bash\ncd 10-parallel-agent\nadk web\n```\n\nThen select \"system_monitor_agent\" from the dropdown menu in the web UI.\n\n## Example Interactions\n\nTry these example prompts:\n\n```\nCheck my system health\n```\n\n```\nProvide a comprehensive system report with recommendations\n```\n\n```\nIs my system running out of memory or disk space?\n```\n\n## Key Concepts: Independent Execution\n\nOne key aspect of Parallel Agents is that **sub-agents run independently without sharing state during execution**. In this example:\n\n1. Each information gathering agent operates in isolation\n2. The results from each agent are collected after parallel execution completes\n3. The synthesizer agent then uses these collected results to create the final report\n\nThis approach is ideal for scenarios where tasks are completely independent and don't require interaction during execution.\n\n## How Parallel Agents Compare to Other Workflow Agents\n\nADK offers different types of workflow agents for different needs:\n\n- **Sequential Agents**: For strict, ordered execution where each step depends on previous outputs\n- **Loop Agents**: For repeated execution of sub-agents based on conditions\n- **Parallel Agents**: For concurrent execution of independent sub-agents (like this example)\n\n## Additional Resources\n\n- [ADK Parallel Agents Documentation](https://google.github.io/adk-docs/agents/workflow-agents/parallel-agents/)\n- [Full Example: Parallel Web Research](https://google.github.io/adk-docs/agents/workflow-agents/parallel-agents/#full-example-parallel-web-research) \n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "11-parallel-agent",
      "type": "documentation",
      "file": "README.md",
      "indexed_at": "2025-07-22T14:24:19.161478"
    },
    "displayName": "ADK Example: 11-parallel-agent (documentation)"
  },
  {
    "id": "adk_code_7bd03759",
    "content": "# ADK Example: 11-parallel-agent\n# File: 11-parallel-agent/system_monitor_agent/agent.py\n\n\"\"\"\nSystem Monitor Root Agent\n\nThis module defines the root agent for the system monitoring application.\nIt uses a parallel agent for system information gathering and a sequential\npipeline for the overall flow.\n\"\"\"\n\nfrom google.adk.agents import ParallelAgent, SequentialAgent\n\nfrom .subagents.cpu_info_agent import cpu_info_agent\nfrom .subagents.disk_info_agent import disk_info_agent\nfrom .subagents.memory_info_agent import memory_info_agent\nfrom .subagents.synthesizer_agent import system_report_synthesizer\n\n# --- 1. Create Parallel Agent to gather information concurrently ---\nsystem_info_gatherer = ParallelAgent(\n    name=\"system_info_gatherer\",\n    sub_agents=[cpu_info_agent, memory_info_agent, disk_info_agent],\n)\n\n# --- 2. Create Sequential Pipeline to gather info in parallel, then synthesize ---\nroot_agent = SequentialAgent(\n    name=\"system_monitor_agent\",\n    sub_agents=[system_info_gatherer, system_report_synthesizer],\n)\n\n\n# This code demonstrates:\n# - ADK patterns for parallel agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "11-parallel-agent",
      "type": "code",
      "file": "11-parallel-agent/system_monitor_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.161657"
    },
    "displayName": "ADK Example: 11-parallel-agent (code)"
  },
  {
    "id": "adk_code_a32a1364",
    "content": "# ADK Example: 11-parallel-agent\n# File: 11-parallel-agent/system_monitor_agent/subagents/disk_info_agent/tools.py\n\n\"\"\"\nDisk Information Tool\n\nThis module provides a tool for gathering disk information.\n\"\"\"\n\nimport time\nfrom typing import Any, Dict\n\nimport psutil\n\n\ndef get_disk_info() -> Dict[str, Any]:\n    \"\"\"\n    Gather disk information including partitions and usage.\n\n    Returns:\n        Dict[str, Any]: Dictionary with disk information structured for ADK\n    \"\"\"\n    try:\n        # Get disk information\n        disk_info = {\"partitions\": []}\n        partitions_over_threshold = []\n        total_space = 0\n        used_space = 0\n\n        for partition in psutil.disk_partitions():\n            try:\n                partition_usage = psutil.disk_usage(partition.mountpoint)\n\n                # Track high usage partitions\n                if partition_usage.percent > 85:\n                    partitions_over_threshold.append(\n                        f\"{partition.mountpoint} ({partition_usage.percent:.1f}%)\"\n                    )\n\n                # Add to totals\n                total_space += partition_usage.total\n                used_space += partition_usage.used\n\n                disk_info[\"partitions\"].append(\n                    {\n                        \"device\": partition.device,\n                        \"mountpoint\": partition.mountpoint,\n                        \"filesystem_type\": partition.fstype,\n                        \"total_size\": f\"{partition_usage.total / (1024 ** 3):.2f} GB\",\n                        \"used\": f\"{partition_usage.used / (1024 ** 3):.2f} GB\",\n                        \"free\": f\"{partition_usage.free / (1024 ** 3):.2f} GB\",\n                        \"percentage\": f\"{partition_usage.percent:.1f}%\",\n                    }\n                )\n            except (PermissionError, FileNotFoundError):\n                # Some partitions may not be accessible\n                pass\n\n        # Calculate overall disk stats\n        overall_usage_percent = (\n            (used_space / total_space * 100) if total_space > 0 else 0\n        )\n\n        # Format for ADK tool return structure\n        return {\n            \"result\": disk_info,\n            \"stats\": {\n                \"partition_count\": len(disk_info[\"partitions\"]),\n                \"total_space_gb\": total_space / (1024**3),\n                \"used_space_gb\": used_space / (1024**3),\n                \"overall_usage_percent\": overall_usage_percent,\n                \"partitions_with_high_usage\": len(partitions_over_threshold),\n            },\n            \"additional_info\": {\n                \"data_format\": \"dictionary\",\n                \"collection_timestamp\": time.time(),\n                \"high_usage_partitions\": (\n                    partitions_over_threshold if partitions_over_threshold else None\n                ),\n            },\n        }\n    except Exception as e:\n        return {\n            \"result\": {\"error\": f\"Failed to gather disk information: {str(e)}\"},\n            \"stats\": {\"success\": False},\n            \"additional_info\": {\"error_type\": str(type(e).__name__)},\n        }\n\n\n# This code demonstrates:\n# - ADK patterns for parallel agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "11-parallel-agent",
      "type": "code",
      "file": "11-parallel-agent/system_monitor_agent/subagents/disk_info_agent/tools.py",
      "indexed_at": "2025-07-22T14:24:19.161942"
    },
    "displayName": "ADK Example: 11-parallel-agent (code)"
  },
  {
    "id": "adk_code_5b5cfd95",
    "content": "# ADK Example: 11-parallel-agent\n# File: 11-parallel-agent/system_monitor_agent/subagents/disk_info_agent/agent.py\n\n\"\"\"\nDisk Information Agent\n\nThis agent is responsible for gathering and analyzing disk information.\n\"\"\"\n\nfrom google.adk.agents import LlmAgent\n\nfrom .tools import get_disk_info\n\n# --- Constants ---\nGEMINI_MODEL = \"gemini-2.0-flash\"\n\n# Disk Information Agent\ndisk_info_agent = LlmAgent(\n    name=\"DiskInfoAgent\",\n    model=GEMINI_MODEL,\n    instruction=\"\"\"You are a Disk Information Agent.\n    \n    When asked for system information, you should:\n    1. Use the 'get_disk_info' tool to gather disk data\n    2. Analyze the returned dictionary data\n    3. Format this information into a concise, clear section of a system report\n    \n    The tool will return a dictionary with:\n    - result: Core disk information including partitions\n    - stats: Key statistical data about storage usage\n    - additional_info: Context about the data collection\n    \n    Format your response as a well-structured report section with:\n    - Partition information\n    - Storage capacity and usage\n    - Any storage concerns (high usage > 85%)\n    \n    IMPORTANT: You MUST call the get_disk_info tool. Do not make up information.\n    \"\"\",\n    description=\"Gathers and analyzes disk information\",\n    tools=[get_disk_info],\n    output_key=\"disk_info\",\n)\n\n\n# This code demonstrates:\n# - ADK patterns for parallel agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "11-parallel-agent",
      "type": "code",
      "file": "11-parallel-agent/system_monitor_agent/subagents/disk_info_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.162038"
    },
    "displayName": "ADK Example: 11-parallel-agent (code)"
  },
  {
    "id": "adk_code_402fffd7",
    "content": "# ADK Example: 11-parallel-agent\n# File: 11-parallel-agent/system_monitor_agent/subagents/synthesizer_agent/agent.py\n\n\"\"\"\nSystem Report Synthesizer Agent\n\nThis agent is responsible for synthesizing information from other agents\nto create a comprehensive system health report.\n\"\"\"\n\nfrom google.adk.agents import LlmAgent\n\n# --- Constants ---\nGEMINI_MODEL = \"gemini-2.0-flash\"\n\n# System Report Synthesizer Agent\nsystem_report_synthesizer = LlmAgent(\n    name=\"SystemReportSynthesizer\",\n    model=GEMINI_MODEL,\n    instruction=\"\"\"You are a System Report Synthesizer.\n    \n    Your task is to create a comprehensive system health report by combining information from:\n    - CPU information: {cpu_info}\n    - Memory information: {memory_info}\n    - Disk information: {disk_info}\n    \n    Create a well-formatted report with:\n    1. An executive summary at the top with overall system health status\n    2. Sections for each component with their respective information\n    3. Recommendations based on any concerning metrics\n    \n    Use markdown formatting to make the report readable and professional.\n    Highlight any concerning values and provide practical recommendations.\n    \"\"\",\n    description=\"Synthesizes all system information into a comprehensive report\",\n)\n\n\n# This code demonstrates:\n# - ADK patterns for parallel agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "11-parallel-agent",
      "type": "code",
      "file": "11-parallel-agent/system_monitor_agent/subagents/synthesizer_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.162234"
    },
    "displayName": "ADK Example: 11-parallel-agent (code)"
  },
  {
    "id": "adk_code_96ae7708",
    "content": "# ADK Example: 11-parallel-agent\n# File: 11-parallel-agent/system_monitor_agent/subagents/cpu_info_agent/tools.py\n\n\"\"\"\nCPU Information Tool\n\nThis module provides a tool for gathering CPU information.\n\"\"\"\n\nimport time\nfrom typing import Any, Dict\n\nimport psutil\n\n\ndef get_cpu_info() -> Dict[str, Any]:\n    \"\"\"\n    Gather CPU information including core count and usage.\n\n    Returns:\n        Dict[str, Any]: Dictionary with CPU information structured for ADK\n    \"\"\"\n    try:\n        # Get CPU information\n        cpu_info = {\n            \"physical_cores\": psutil.cpu_count(logical=False),\n            \"logical_cores\": psutil.cpu_count(logical=True),\n            \"cpu_usage_per_core\": [\n                f\"Core {i}: {percentage:.1f}%\"\n                for i, percentage in enumerate(\n                    psutil.cpu_percent(interval=1, percpu=True)\n                )\n            ],\n            \"avg_cpu_usage\": f\"{psutil.cpu_percent(interval=1):.1f}%\",\n        }\n\n        # Calculate some stats for the result summary\n        avg_usage = float(cpu_info[\"avg_cpu_usage\"].strip(\"%\"))\n        high_usage = avg_usage > 80\n\n        # Format for ADK tool return structure\n        return {\n            \"result\": cpu_info,\n            \"stats\": {\n                \"physical_cores\": cpu_info[\"physical_cores\"],\n                \"logical_cores\": cpu_info[\"logical_cores\"],\n                \"avg_usage_percentage\": avg_usage,\n                \"high_usage_alert\": high_usage,\n            },\n            \"additional_info\": {\n                \"data_format\": \"dictionary\",\n                \"collection_timestamp\": time.time(),\n                \"performance_concern\": (\n                    \"High CPU usage detected\" if high_usage else None\n                ),\n            },\n        }\n    except Exception as e:\n        return {\n            \"result\": {\"error\": f\"Failed to gather CPU information: {str(e)}\"},\n            \"stats\": {\"success\": False},\n            \"additional_info\": {\"error_type\": str(type(e).__name__)},\n        }\n\n\n# This code demonstrates:\n# - ADK patterns for parallel agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "11-parallel-agent",
      "type": "code",
      "file": "11-parallel-agent/system_monitor_agent/subagents/cpu_info_agent/tools.py",
      "indexed_at": "2025-07-22T14:24:19.162395"
    },
    "displayName": "ADK Example: 11-parallel-agent (code)"
  },
  {
    "id": "adk_code_16f0de30",
    "content": "# ADK Example: 11-parallel-agent\n# File: 11-parallel-agent/system_monitor_agent/subagents/cpu_info_agent/agent.py\n\n\"\"\"\nCPU Information Agent\n\nThis agent is responsible for gathering and analyzing CPU information.\n\"\"\"\n\nfrom google.adk.agents import LlmAgent\n\nfrom .tools import get_cpu_info\n\n# --- Constants ---\nGEMINI_MODEL = \"gemini-2.0-flash\"\n\n# CPU Information Agent\ncpu_info_agent = LlmAgent(\n    name=\"CpuInfoAgent\",\n    model=GEMINI_MODEL,\n    instruction=\"\"\"You are a CPU Information Agent.\n    \n    When asked for system information, you should:\n    1. Use the 'get_cpu_info' tool to gather CPU data\n    2. Analyze the returned dictionary data\n    3. Format this information into a concise, clear section of a system report\n    \n    The tool will return a dictionary with:\n    - result: Core CPU information\n    - stats: Key statistical data about CPU usage\n    - additional_info: Context about the data collection\n    \n    Format your response as a well-structured report section with:\n    - CPU core information (physical vs logical)\n    - CPU usage statistics\n    - Any performance concerns (high usage > 80%)\n    \n    IMPORTANT: You MUST call the get_cpu_info tool. Do not make up information.\n    \"\"\",\n    description=\"Gathers and analyzes CPU information\",\n    tools=[get_cpu_info],\n    output_key=\"cpu_info\",\n)\n\n\n# This code demonstrates:\n# - ADK patterns for parallel agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "11-parallel-agent",
      "type": "code",
      "file": "11-parallel-agent/system_monitor_agent/subagents/cpu_info_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.162507"
    },
    "displayName": "ADK Example: 11-parallel-agent (code)"
  },
  {
    "id": "adk_code_b8f8448f",
    "content": "# ADK Example: 11-parallel-agent\n# File: 11-parallel-agent/system_monitor_agent/subagents/memory_info_agent/tools.py\n\n\"\"\"\nMemory Information Tool\n\nThis module provides a tool for gathering memory information.\n\"\"\"\n\nimport time\nfrom typing import Any, Dict\n\nimport psutil\n\n\ndef get_memory_info() -> Dict[str, Any]:\n    \"\"\"\n    Gather memory information including RAM and swap usage.\n\n    Returns:\n        Dict[str, Any]: Dictionary with memory information structured for ADK\n    \"\"\"\n    try:\n        # Get memory information\n        memory = psutil.virtual_memory()\n        swap = psutil.swap_memory()\n\n        memory_info = {\n            \"total_memory\": f\"{memory.total / (1024 ** 3):.2f} GB\",\n            \"available_memory\": f\"{memory.available / (1024 ** 3):.2f} GB\",\n            \"used_memory\": f\"{memory.used / (1024 ** 3):.2f} GB\",\n            \"memory_percentage\": f\"{memory.percent:.1f}%\",\n            \"swap_total\": f\"{swap.total / (1024 ** 3):.2f} GB\",\n            \"swap_used\": f\"{swap.used / (1024 ** 3):.2f} GB\",\n            \"swap_percentage\": f\"{swap.percent:.1f}%\",\n        }\n\n        # Calculate stats\n        memory_usage = memory.percent\n        swap_usage = swap.percent\n        high_memory_usage = memory_usage > 80\n        high_swap_usage = swap_usage > 80\n\n        # Format for ADK tool return structure\n        return {\n            \"result\": memory_info,\n            \"stats\": {\n                \"memory_usage_percentage\": memory_usage,\n                \"swap_usage_percentage\": swap_usage,\n                \"total_memory_gb\": memory.total / (1024**3),\n                \"available_memory_gb\": memory.available / (1024**3),\n            },\n            \"additional_info\": {\n                \"data_format\": \"dictionary\",\n                \"collection_timestamp\": time.time(),\n                \"performance_concern\": (\n                    \"High memory usage detected\" if high_memory_usage else None\n                ),\n                \"swap_concern\": \"High swap usage detected\" if high_swap_usage else None,\n            },\n        }\n    except Exception as e:\n        return {\n            \"result\": {\"error\": f\"Failed to gather memory information: {str(e)}\"},\n            \"stats\": {\"success\": False},\n            \"additional_info\": {\"error_type\": str(type(e).__name__)},\n        }\n\n\n# This code demonstrates:\n# - ADK patterns for parallel agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "11-parallel-agent",
      "type": "code",
      "file": "11-parallel-agent/system_monitor_agent/subagents/memory_info_agent/tools.py",
      "indexed_at": "2025-07-22T14:24:19.162866"
    },
    "displayName": "ADK Example: 11-parallel-agent (code)"
  },
  {
    "id": "adk_code_af36a662",
    "content": "# ADK Example: 11-parallel-agent\n# File: 11-parallel-agent/system_monitor_agent/subagents/memory_info_agent/agent.py\n\n\"\"\"\nMemory Information Agent\n\nThis agent is responsible for gathering and analyzing memory information.\n\"\"\"\n\nfrom google.adk.agents import LlmAgent\n\nfrom .tools import get_memory_info\n\n# --- Constants ---\nGEMINI_MODEL = \"gemini-2.0-flash\"\n\n# Memory Information Agent\nmemory_info_agent = LlmAgent(\n    name=\"MemoryInfoAgent\",\n    model=GEMINI_MODEL,\n    instruction=\"\"\"You are a Memory Information Agent.\n    \n    When asked for system information, you should:\n    1. Use the 'get_memory_info' tool to gather memory data\n    2. Analyze the returned dictionary data\n    3. Format this information into a concise, clear section of a system report\n    \n    The tool will return a dictionary with:\n    - result: Core memory information\n    - stats: Key statistical data about memory usage\n    - additional_info: Context about the data collection\n    \n    Format your response as a well-structured report section with:\n    - Total and available memory\n    - Memory usage statistics\n    - Swap memory information\n    - Any performance concerns (high usage > 80%)\n    \n    IMPORTANT: You MUST call the get_memory_info tool. Do not make up information.\n    \"\"\",\n    description=\"Gathers and analyzes memory information\",\n    tools=[get_memory_info],\n    output_key=\"memory_info\",\n)\n\n\n# This code demonstrates:\n# - ADK patterns for parallel agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "11-parallel-agent",
      "type": "code",
      "file": "11-parallel-agent/system_monitor_agent/subagents/memory_info_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.162960"
    },
    "displayName": "ADK Example: 11-parallel-agent (code)"
  },
  {
    "id": "adk_example_12-loop-agent",
    "content": "# LinkedIn Post Generator Loop Agent\n\nThis example demonstrates the use of a Sequential and Loop Agent pattern in the Agent Development Kit (ADK) to generate and refine a LinkedIn post.\n\n## Overview\n\nThe LinkedIn Post Generator uses a sequential pipeline with a loop component to:\n1. Generate an initial LinkedIn post\n2. Iteratively refine the post until quality requirements are met\n\nThis demonstrates several key patterns:\n1. **Sequential Pipeline**: A multi-step workflow with distinct stages\n2. **Iterative Refinement**: Using a loop to repeatedly refine content\n3. **Automatic Quality Checking**: Validating content against specific criteria\n4. **Feedback-Driven Refinement**: Improving content based on specific feedback\n5. **Loop Exit Tool**: Using a tool to terminate the loop when quality requirements are met\n\n## Architecture\n\nThe system is composed of the following components:\n\n### Root Sequential Agent\n\n`LinkedInPostGenerationPipeline` - A SequentialAgent that orchestrates the overall process:\n1. First runs the initial post generator\n2. Then executes the refinement loop\n\n### Initial Post Generator\n\n`InitialPostGenerator` - An LlmAgent that creates the first draft of the LinkedIn post with no prior context.\n\n### Refinement Loop\n\n`PostRefinementLoop` - A LoopAgent that executes a two-stage refinement process:\n1. First runs the reviewer to evaluate the post and possibly exit the loop\n2. Then runs the refiner to improve the post if the loop continues\n\n### Sub-Agents Inside the Refinement Loop\n\n1. **Post Reviewer** (`PostReviewer`) - Reviews posts for quality and provides feedback or exits the loop if requirements are met\n2. **Post Refiner** (`PostRefiner`) - Refines the post based on feedback to improve quality\n\n### Tools\n\n1. **Character Counter** - Validates post length against requirements (used by the Reviewer)\n2. **Exit Loop** - Terminates the loop when all quality criteria are satisfied (used by the Reviewer)\n\n## Loop Control with Exit Tool\n\nA key design pattern in this example is the use of an `exit_loop` tool to control when the loop terminates. The Post Reviewer has two responsibilities:\n\n1. **Quality Evaluation**: Checks if the post meets all requirements\n2. **Loop Control**: Calls the exit_loop tool when the post passes all quality checks\n\nWhen the exit_loop tool is called:\n1. It sets `tool_context.actions.escalate = True`\n2. This signals to the LoopAgent that it should stop iterating\n\nThis approach follows ADK best practices by:\n1. Separating initial generation from refinement\n2. Giving the quality reviewer direct control over loop termination\n3. Using a dedicated agent for post refinement\n4. Using a tool to manage the loop control flow\n\n## Usage\n\nTo run this example:\n\n```bash\ncd 11-loop-agent\nadk web\n```\n\nThen in the web interface, enter a prompt like:\n\"Generate a LinkedIn post about what I've learned from @aiwithbrandon's Agent Development Kit tutorial.\"\n\nThe system will:\n1. Generate an initial LinkedIn post\n2. Review the post for quality and compliance with requirements\n3. If the post meets all requirements, exit the loop\n4. Otherwise, provide feedback and refine the post\n5. Continue this process until a satisfactory post is created or max iterations reached\n6. Return the final post\n\n## Example Input\n\n```\nGenerate a LinkedIn post about what I've learned from @aiwithbrandon's Agent Development Kit tutorial.\n```\n\n## Loop Termination\n\nThe loop terminates in one of two ways:\n1. When the post meets all quality requirements (reviewer calls the exit_loop tool)\n2. After reaching the maximum number of iterations (10)\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "12-loop-agent",
      "type": "documentation",
      "file": "README.md",
      "indexed_at": "2025-07-22T14:24:19.163547"
    },
    "displayName": "ADK Example: 12-loop-agent (documentation)"
  },
  {
    "id": "adk_code_138ea97d",
    "content": "# ADK Example: 12-loop-agent\n# File: 12-loop-agent/linkedin_post_agent/agent.py\n\n\"\"\"\nLinkedIn Post Generator Root Agent\n\nThis module defines the root agent for the LinkedIn post generation application.\nIt uses a sequential agent with an initial post generator followed by a refinement loop.\n\"\"\"\n\nfrom google.adk.agents import LoopAgent, SequentialAgent\n\nfrom .subagents.post_generator import initial_post_generator\nfrom .subagents.post_refiner import post_refiner\nfrom .subagents.post_reviewer import post_reviewer\n\n# Create the Refinement Loop Agent\nrefinement_loop = LoopAgent(\n    name=\"PostRefinementLoop\",\n    max_iterations=10,\n    sub_agents=[\n        post_reviewer,\n        post_refiner,\n    ],\n    description=\"Iteratively reviews and refines a LinkedIn post until quality requirements are met\",\n)\n\n# Create the Sequential Pipeline\nroot_agent = SequentialAgent(\n    name=\"LinkedInPostGenerationPipeline\",\n    sub_agents=[\n        initial_post_generator,  # Step 1: Generate initial post\n        refinement_loop,  # Step 2: Review and refine in a loop\n    ],\n    description=\"Generates and refines a LinkedIn post through an iterative review process\",\n)\n\n\n# This code demonstrates:\n# - ADK patterns for loop agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "12-loop-agent",
      "type": "code",
      "file": "12-loop-agent/linkedin_post_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.163797"
    },
    "displayName": "ADK Example: 12-loop-agent (code)"
  },
  {
    "id": "adk_code_057ecda6",
    "content": "# ADK Example: 12-loop-agent\n# File: 12-loop-agent/linkedin_post_agent/subagents/post_reviewer/tools.py\n\n\"\"\"\nTools for LinkedIn Post Reviewer Agent\n\nThis module provides tools for analyzing and validating LinkedIn posts.\n\"\"\"\n\nfrom typing import Any, Dict\n\nfrom google.adk.tools.tool_context import ToolContext\n\n\ndef count_characters(text: str, tool_context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    Tool to count characters in the provided text and provide length-based feedback.\n    Updates review_status in the state based on length requirements.\n\n    Args:\n        text: The text to analyze for character count\n        tool_context: Context for accessing and updating session state\n\n    Returns:\n        Dict[str, Any]: Dictionary containing:\n            - result: 'fail' or 'pass'\n            - char_count: number of characters in text\n            - message: feedback message about the length\n    \"\"\"\n    char_count = len(text)\n    MIN_LENGTH = 1000\n    MAX_LENGTH = 1500\n\n    print(\"\\n----------- TOOL DEBUG -----------\")\n    print(f\"Checking text length: {char_count} characters\")\n    print(\"----------------------------------\\n\")\n\n    if char_count < MIN_LENGTH:\n        chars_needed = MIN_LENGTH - char_count\n        tool_context.state[\"review_status\"] = \"fail\"\n        return {\n            \"result\": \"fail\",\n            \"char_count\": char_count,\n            \"chars_needed\": chars_needed,\n            \"message\": f\"Post is too short. Add {chars_needed} more characters to reach minimum length of {MIN_LENGTH}.\",\n        }\n    elif char_count > MAX_LENGTH:\n        chars_to_remove = char_count - MAX_LENGTH\n        tool_context.state[\"review_status\"] = \"fail\"\n        return {\n            \"result\": \"fail\",\n            \"char_count\": char_count,\n            \"chars_to_remove\": chars_to_remove,\n            \"message\": f\"Post is too long. Remove {chars_to_remove} characters to meet maximum length of {MAX_LENGTH}.\",\n        }\n    else:\n        tool_context.state[\"review_status\"] = \"pass\"\n        return {\n            \"result\": \"pass\",\n            \"char_count\": char_count,\n            \"message\": f\"Post length is good ({char_count} characters).\",\n        }\n\n\ndef exit_loop(tool_context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    Call this function ONLY when the post meets all quality requirements,\n    signaling the iterative process should end.\n\n    Args:\n        tool_context: Context for tool execution\n\n    Returns:\n        Empty dictionary\n    \"\"\"\n    print(\"\\n----------- EXIT LOOP TRIGGERED -----------\")\n    print(\"Post review completed successfully\")\n    print(\"Loop will exit now\")\n    print(\"------------------------------------------\\n\")\n\n    tool_context.actions.escalate = True\n    return {}\n\n\n# This code demonstrates:\n# - ADK patterns for loop agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "12-loop-agent",
      "type": "code",
      "file": "12-loop-agent/linkedin_post_agent/subagents/post_reviewer/tools.py",
      "indexed_at": "2025-07-22T14:24:19.164108"
    },
    "displayName": "ADK Example: 12-loop-agent (code)"
  },
  {
    "id": "adk_code_1b67f9c4",
    "content": "# ADK Example: 12-loop-agent\n# File: 12-loop-agent/linkedin_post_agent/subagents/post_reviewer/agent.py\n\n\"\"\"\nLinkedIn Post Reviewer Agent\n\nThis agent reviews LinkedIn posts for quality and provides feedback.\n\"\"\"\n\nfrom google.adk.agents.llm_agent import LlmAgent\n\nfrom .tools import count_characters, exit_loop\n\n# Constants\nGEMINI_MODEL = \"gemini-2.0-flash\"\n\n# Define the Post Reviewer Agent\npost_reviewer = LlmAgent(\n    name=\"PostReviewer\",\n    model=GEMINI_MODEL,\n    instruction=\"\"\"You are a LinkedIn Post Quality Reviewer.\n\n    Your task is to evaluate the quality of a LinkedIn post about Agent Development Kit (ADK).\n    \n    ## EVALUATION PROCESS\n    1. Use the count_characters tool to check the post's length.\n       Pass the post text directly to the tool.\n    \n    2. If the length check fails (tool result is \"fail\"), provide specific feedback on what needs to be fixed.\n       Use the tool's message as a guideline, but add your own professional critique.\n    \n    3. If length check passes, evaluate the post against these criteria:\n       - REQUIRED ELEMENTS:\n         1. Mentions @aiwithbrandon\n         2. Lists multiple ADK capabilities (at least 4)\n         3. Has a clear call-to-action\n         4. Includes practical applications\n         5. Shows genuine enthusiasm\n       \n       - STYLE REQUIREMENTS:\n         1. NO emojis\n         2. NO hashtags\n         3. Professional tone\n         4. Conversational style\n         5. Clear and concise writing\n    \n    ## OUTPUT INSTRUCTIONS\n    IF the post fails ANY of the checks above:\n      - Return concise, specific feedback on what to improve\n      \n    ELSE IF the post meets ALL requirements:\n      - Call the exit_loop function\n      - Return \"Post meets all requirements. Exiting the refinement loop.\"\n      \n    Do not embellish your response. Either provide feedback on what to improve OR call exit_loop and return the completion message.\n    \n    ## POST TO REVIEW\n    {current_post}\n    \"\"\",\n    description=\"Reviews post quality and provides feedback on what to improve or exits the loop if requirements are met\",\n    tools=[count_characters, exit_loop],\n    output_key=\"review_feedback\",\n)\n\n\n# This code demonstrates:\n# - ADK patterns for loop agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "12-loop-agent",
      "type": "code",
      "file": "12-loop-agent/linkedin_post_agent/subagents/post_reviewer/agent.py",
      "indexed_at": "2025-07-22T14:24:19.164234"
    },
    "displayName": "ADK Example: 12-loop-agent (code)"
  },
  {
    "id": "adk_code_259632cc",
    "content": "# ADK Example: 12-loop-agent\n# File: 12-loop-agent/linkedin_post_agent/subagents/post_generator/agent.py\n\n\"\"\"\nLinkedIn Post Generator Agent\n\nThis agent generates the initial LinkedIn post before refinement.\n\"\"\"\n\nfrom google.adk.agents.llm_agent import LlmAgent\n\n# Constants\nGEMINI_MODEL = \"gemini-2.0-flash\"\n\n# Define the Initial Post Generator Agent\ninitial_post_generator = LlmAgent(\n    name=\"InitialPostGenerator\",\n    model=GEMINI_MODEL,\n    instruction=\"\"\"You are a LinkedIn Post Generator.\n\n    Your task is to create a LinkedIn post about an Agent Development Kit (ADK) tutorial by @aiwithbrandon.\n    \n    ## CONTENT REQUIREMENTS\n    Ensure the post includes:\n    1. Excitement about learning from the tutorial\n    2. Specific aspects of ADK learned:\n       - Basic agent implementation (basic-agent)\n       - Tool integration (tool-agent)\n       - Using LiteLLM (litellm-agent)\n       - Managing sessions and memory\n       - Persistent storage capabilities\n       - Multi-agent orchestration\n       - Stateful multi-agent systems\n       - Callback systems\n       - Sequential agents for pipeline workflows\n       - Parallel agents for concurrent operations\n       - Loop agents for iterative refinement\n    3. Brief statement about improving AI applications\n    4. Mention/tag of @aiwithbrandon\n    5. Clear call-to-action for connections\n    \n    ## STYLE REQUIREMENTS\n    - Professional and conversational tone\n    - Between 1000-1500 characters\n    - NO emojis\n    - NO hashtags\n    - Show genuine enthusiasm\n    - Highlight practical applications\n    \n    ## OUTPUT INSTRUCTIONS\n    - Return ONLY the post content\n    - Do not add formatting markers or explanations\n    \"\"\",\n    description=\"Generates the initial LinkedIn post to start the refinement process\",\n    output_key=\"current_post\",\n)\n\n\n# This code demonstrates:\n# - ADK patterns for loop agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "12-loop-agent",
      "type": "code",
      "file": "12-loop-agent/linkedin_post_agent/subagents/post_generator/agent.py",
      "indexed_at": "2025-07-22T14:24:19.164321"
    },
    "displayName": "ADK Example: 12-loop-agent (code)"
  },
  {
    "id": "adk_code_1575e57b",
    "content": "# ADK Example: 12-loop-agent\n# File: 12-loop-agent/linkedin_post_agent/subagents/post_refiner/agent.py\n\n\"\"\"\nLinkedIn Post Refiner Agent\n\nThis agent refines LinkedIn posts based on review feedback.\n\"\"\"\n\nfrom google.adk.agents.llm_agent import LlmAgent\n\n# Constants\nGEMINI_MODEL = \"gemini-2.0-flash\"\n\n# Define the Post Refiner Agent\npost_refiner = LlmAgent(\n    name=\"PostRefinerAgent\",\n    model=GEMINI_MODEL,\n    instruction=\"\"\"You are a LinkedIn Post Refiner.\n\n    Your task is to refine a LinkedIn post based on review feedback.\n    \n    ## INPUTS\n    **Current Post:**\n    {current_post}\n    \n    **Review Feedback:**\n    {review_feedback}\n    \n    ## TASK\n    Carefully apply the feedback to improve the post.\n    - Maintain the original tone and theme of the post\n    - Ensure all content requirements are met:\n      1. Excitement about learning from the tutorial\n      2. Specific aspects of ADK learned (at least 4)\n      3. Brief statement about improving AI applications\n      4. Mention/tag of @aiwithbrandon\n      5. Clear call-to-action for connections\n    - Adhere to style requirements:\n      - Professional and conversational tone\n      - Between 1000-1500 characters\n      - NO emojis\n      - NO hashtags\n      - Show genuine enthusiasm\n      - Highlight practical applications\n    \n    ## OUTPUT INSTRUCTIONS\n    - Output ONLY the refined post content\n    - Do not add explanations or justifications\n    \"\"\",\n    description=\"Refines LinkedIn posts based on feedback to improve quality\",\n    output_key=\"current_post\",\n)\n\n\n# This code demonstrates:\n# - ADK patterns for loop agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "12-loop-agent",
      "type": "code",
      "file": "12-loop-agent/linkedin_post_agent/subagents/post_refiner/agent.py",
      "indexed_at": "2025-07-22T14:24:19.164402"
    },
    "displayName": "ADK Example: 12-loop-agent (code)"
  },
  {
    "id": "adk_example_2-tool-agent",
    "content": "# Tool Agent Example\n\n## What is a Tool Agent?\n\nA Tool Agent extends the basic ADK agent by incorporating tools that allow the agent to perform actions beyond just generating text responses. Tools enable agents to interact with external systems, retrieve information, and perform specific functions to accomplish tasks more effectively.\n\nIn this example, we demonstrate how to build an agent that can use built-in tools (like Google Search) and custom function tools to enhance its capabilities.\n\n## Key Components\n\n### 1. Built-in Tools\nADK provides several built-in tools that you can use with your agents:\n\n- **Google Search**: Allows your agent to search the web for information\n- **Code Execution**: Enables your agent to run code snippets\n- **Vertex AI Search**: Lets your agent search through your own data\n\n**Important Note**: Currently, for each root agent or single agent, only one built-in tool is supported. See the [ADK documentation](https://google.github.io/adk-docs/tools/built-in-tools/#use-built-in-tools-with-other-tools) for more details.\n\n### 2. Custom Function Tools\nYou can create your own tools by defining Python functions. These custom tools extend your agent's capabilities to perform specific tasks.\n\n#### Best Practices for Custom Function Tools:\n\n- **Parameters**: Define your function parameters using standard JSON-serializable types (string, integer, list, dictionary)\n- **No Default Values**: Default values are not currently supported in ADK\n- **Return Type**: The preferred return type is a dictionary\n  - If you don't return a dictionary, ADK will wrap it into a dictionary `{\"result\": ...}`\n  - Best practice format: `{\"status\": \"success\", \"error_message\": None, \"result\": \"...\"}`\n- **Docstrings**: The function's docstring serves as the tool's description and is sent to the LLM\n  - Focus on clarity so the LLM understands how to use the tool effectively\n\n## Limitations\n\nWhen working with built-in tools in ADK, there are several important limitations to be aware of:\n\n### Single Built-in Tool Restriction\n\n**Currently, for each root agent or single agent, only one built-in tool is supported.**\n\nFor example, this approach using two built-in tools within a single agent is **not** currently supported:\n\n```python\nroot_agent = Agent(\n    name=\"RootAgent\",\n    model=\"gemini-2.0-flash\",\n    description=\"Root Agent\",\n    tools=[built_in_code_execution, google_search],  # NOT SUPPORTED\n)\n```\n\n### Built-in Tools vs. Custom Tools\n\n**You cannot mix built-in tools with custom function tools in the same agent.**\n\nFor example, this approach is **not** currently supported:\n\n```python\ndef get_current_time() -> dict:\n    \"\"\"Get the current time in the format YYYY-MM-DD HH:MM:SS\"\"\"\n    return {\n        \"current_time\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n    }\n\nroot_agent = Agent(\n    name=\"RootAgent\",\n    model=\"gemini-2.0-flash\",\n    description=\"Root Agent\",\n    tools=[google_search, get_current_time],  # NOT SUPPORTED\n)\n```\n\nTo use both types of tools, you would need to use the Agent Tool approach described in the Multi-Agent example.\n\n## Implementation Example\n\n### Understanding the Code\n\nThe agent.py file defines a tool agent that can use Google Search to find information on the web. The agent is configured with:\n\n1. A name and description\n2. The Gemini model to use\n3. Instructions that tell the agent how to behave and what tools it can use\n4. The tools it can access (in this case, google_search)\n\nThe file also includes a commented-out example of a custom function tool `get_current_time()` that could be uncommented to explore custom tool functionality.\n\n### Getting Started\n\nThis example uses the same virtual environment created in the root directory. Make sure you have:\n\n1. Activated the virtual environment from the root directory:\n```bash\n# macOS/Linux:\nsource ../.venv/bin/activate\n# Windows CMD:\n..\\.venv\\Scripts\\activate.bat\n# Windows PowerShell:\n..\\.venv\\Scripts\\Activate.ps1\n```\n\n2. Set up your API key:\n   - Rename `.env.example` to `.env` in the tool_agent folder\n   - Add your Google API key to the `GOOGLE_API_KEY` variable in the `.env` file\n\n### Running the Example\n\nTo run the tool agent example:\n\n1. Navigate to the 2-tool-agent directory containing your agent folder.\n\n2. Start the interactive web UI:\n```bash\nadk web\n```\n\n3. Access the web UI by opening the URL shown in your terminal (typically http://localhost:8000)\n\n4. Select the \"tool_agent\" from the dropdown menu in the top-left corner of the UI\n\n5. Start chatting with your agent in the textbox at the bottom of the screen\n\nThe ADK CLI tool provides several options:\n\n- **`adk web`**: Launches an interactive web UI for testing your agent with a chat interface\n- **`adk run tool_agent`**: Runs your agent directly in the terminal\n- **`adk api_server`**: Starts a FastAPI server to test API requests to your agent\n\n### Example Prompts to Try\n\n- \"Search for recent news about artificial intelligence\"\n- \"Find information about Google's Agent Development Kit\"\n- \"What are the latest advancements in quantum computing?\"\n\nYou can exit the conversation or stop the server by pressing `Ctrl+C` in your terminal.\n\n## Additional Resources\n\n- [Types of tools](https://google.github.io/adk-docs/tools/#full-example-tavily-search)\n- [ADK Function Tools Documentation](https://google.github.io/adk-docs/tools/function-tools/)\n- [ADK Built-in Tools Documentation](https://google.github.io/adk-docs/tools/built-in-tools/)\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "2-tool-agent",
      "type": "documentation",
      "file": "README.md",
      "indexed_at": "2025-07-22T14:24:19.164590"
    },
    "displayName": "ADK Example: 2-tool-agent (documentation)"
  },
  {
    "id": "adk_code_ffdf2dc7",
    "content": "# ADK Example: 2-tool-agent\n# File: 2-tool-agent/tool_agent/agent.py\n\nfrom google.adk.agents import Agent\nfrom google.adk.tools import google_search\n\n# def get_current_time() -> dict:\n#     \"\"\"\n#     Get the current time in the format YYYY-MM-DD HH:MM:SS\n#     \"\"\"\n#     return {\n#         \"current_time\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n#     }\n\nroot_agent = Agent(\n    name=\"tool_agent\",\n    model=\"gemini-2.0-flash\",\n    description=\"Tool agent\",\n    instruction=\"\"\"\n    You are a helpful assistant that can use the following tools:\n    - google_search\n    \"\"\",\n    tools=[google_search],\n    # tools=[get_current_time],\n    # tools=[google_search, get_current_time], # <--- Doesn't work\n)\n\n\n# This code demonstrates:\n# - ADK patterns for tool agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "2-tool-agent",
      "type": "code",
      "file": "2-tool-agent/tool_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.164712"
    },
    "displayName": "ADK Example: 2-tool-agent (code)"
  },
  {
    "id": "adk_example_3-litellm-agent",
    "content": "# LiteLLM Agent Example\n\n## What is LiteLLM?\n\nLiteLLM is a Python library that provides a unified interface for interacting with multiple Large Language Model (LLM) providers through a single, consistent API. It serves as an adapter that allows you to:\n\n- Use the same code to access 100+ different LLMs from providers like OpenAI, Anthropic, Google, AWS Bedrock, and more\n- Standardize inputs and outputs across different LLM providers\n- Track costs, manage API keys, and handle errors consistently\n- Implement fallbacks and load balancing across different models\n\nIn essence, LiteLLM acts as a unified wrapper that makes it easy to switch between different LLM providers without changing your application code.\n\n## Why Use LiteLLM with ADK?\n\nThe Agent Development Kit (ADK) is designed to be model-agnostic, meaning it can work with various LLM providers. LiteLLM enhances this capability by:\n\n1. **Provider Flexibility**: Easily switch between LLM providers (OpenAI, Anthropic, etc.) without changing your agent code\n2. **Cost Optimization**: Choose the most cost-effective model for your specific use case\n3. **Model Exploration**: Experiment with different models to find the best performance for your task\n4. **Future-Proofing**: As new models are released, you can quickly adopt them without major code changes\n\nThis example demonstrates how to use LiteLLM with ADK to create an agent powered by models through OpenRouter rather than Google's Gemini models.\n\n## Limitations When Using Non-Google Models\n\nWhen using LiteLLM to integrate non-Google models with ADK, there are some important limitations to be aware of:\n\n1. **No Access to Google Built-in Tools**: Non-Google models (like OpenAI, Anthropic, etc.) cannot use ADK's built-in Google tools such as:\n   - Google Search\n   - Code Execution\n   - Vertex AI Search\n\n2. **Custom Function Tools Only**: When using non-Google models, you can only use custom function tools (like the `get_dad_joke()` function in this example).\n\n\nThese limitations exist because built-in tools are specifically designed to work with Google's models and infrastructure. However, you can still create powerful agents using custom function tools and the wide variety of models available through LiteLLM.\n\n## Getting Started\n\nThis example uses the same virtual environment created in the root directory. Make sure you have:\n\n1. Activated the virtual environment from the root directory:\n```bash\n# macOS/Linux:\nsource ../.venv/bin/activate\n# Windows CMD:\n..\\.venv\\Scripts\\activate.bat\n# Windows PowerShell:\n..\\.venv\\Scripts\\Activate.ps1\n```\n\n2. Set up your OpenRouter API key:\n   - Create an account at [OpenRouter](https://openrouter.ai/) if you don't have one\n   - Generate an API key at https://openrouter.ai/keys\n   - Rename `.env.example` to `.env` in the openrouter_dad_joke_agent folder\n   - Add your OpenRouter API key to the `OPENROUTER_API_KEY` variable in the `.env` file\n\n## Understanding the Code\n\nThis example demonstrates:\n\n1. How to use the `LiteLlm` model adapter with ADK\n2. How to connect to models through OpenRouter (specifically Claude 3.5 Sonnet)\n3. How to create a simple agent with a custom tool\n\nThe agent is configured to tell dad jokes using a custom function tool `get_dad_joke()` and powered by Anthropic's Claude 3.5 Sonnet model through OpenRouter instead of Google's Gemini.\n\n## Running the Example\n\nTo run the LiteLLM agent example:\n\n1. Navigate to the 3-litellm-agent directory containing your agent folder.\n\n2. Start the interactive web UI:\n```bash\nadk web\n```\n\n3. Access the web UI by opening the URL shown in your terminal (typically http://localhost:8000)\n\n4. Select the \"openrouter_dad_joke_agent\" from the dropdown menu in the top-left corner of the UI\n\n5. Start chatting with your agent in the textbox at the bottom of the screen\n\n### Example Prompts to Try\n\n- \"Tell me a dad joke\"\n\nYou can exit the conversation or stop the server by pressing `Ctrl+C` in your terminal.\n\n## Modifying the Example\n\nYou can easily modify this example to use different models from different providers through OpenRouter by changing the `LiteLlm` configuration. For example:\n\n```python\n# To use Claude 3.5 Sonnet from Anthropic through OpenRouter\nmodel = LiteLlm(\n    model=\"openrouter/anthropic/claude-3-5-sonnet\",\n    api_key=os.getenv(\"OPENROUTER_API_KEY\"),\n)\n\n# To use GPT-4o from OpenAI through OpenRouter\nmodel = LiteLlm(\n    model=\"openrouter/openai/gpt-4o\",\n    api_key=os.getenv(\"OPENROUTER_API_KEY\"),\n)\n\n# To use Llama 3 70B from Meta through OpenRouter\nmodel = LiteLlm(\n    model=\"openrouter/meta-llama/meta-llama-3-70b-instruct\",\n    api_key=os.getenv(\"OPENROUTER_API_KEY\"),\n)\n\n# To use Mistral Large through OpenRouter\nmodel = LiteLlm(\n    model=\"openrouter/mistral/mistral-large-latest\",\n    api_key=os.getenv(\"OPENROUTER_API_KEY\"),\n)\n```\n\n## Additional Resources\n\n- [Google ADK LiteLLM Integration Documentation](https://google.github.io/adk-docs/tutorials/agent-team/#step-2-going-multi-model-with-litellm-optional)\n- [LiteLLM Documentation](https://docs.litellm.ai/docs/)\n- [LiteLLM Supported Providers](https://docs.litellm.ai/docs/providers)\n- [OpenRouter Documentation](https://openrouter.ai/docs)\n- [Anthropic Claude Models Overview](https://docs.anthropic.com/en/docs/about-claude/models/all-models)\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "3-litellm-agent",
      "type": "documentation",
      "file": "README.md",
      "indexed_at": "2025-07-22T14:24:19.164926"
    },
    "displayName": "ADK Example: 3-litellm-agent (documentation)"
  },
  {
    "id": "adk_code_24d41dd0",
    "content": "# ADK Example: 3-litellm-agent\n# File: 3-litellm-agent/dad_joke_agent/agent.py\n\nimport os\nimport random\n\nfrom google.adk.agents import Agent\nfrom google.adk.models.lite_llm import LiteLlm\n\n# https://docs.litellm.ai/docs/providers/openrouter\nmodel = LiteLlm(\n    model=\"openrouter/openai/gpt-4.1\",\n    api_key=os.getenv(\"OPENROUTER_API_KEY\"),\n)\n\n\ndef get_dad_joke():\n    jokes = [\n        \"Why did the chicken cross the road? To get to the other side!\",\n        \"What do you call a belt made of watches? A waist of time.\",\n        \"What do you call fake spaghetti? An impasta!\",\n        \"Why did the scarecrow win an award? Because he was outstanding in his field!\",\n    ]\n    return random.choice(jokes)\n\n\nroot_agent = Agent(\n    name=\"dad_joke_agent\",\n    model=model,\n    description=\"Dad joke agent\",\n    instruction=\"\"\"\n    You are a helpful assistant that can tell dad jokes. \n    Only use the tool `get_dad_joke` to tell jokes.\n    \"\"\",\n    tools=[get_dad_joke],\n)\n\n\n# This code demonstrates:\n# - ADK patterns for litellm agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "3-litellm-agent",
      "type": "code",
      "file": "3-litellm-agent/dad_joke_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.165040"
    },
    "displayName": "ADK Example: 3-litellm-agent (code)"
  },
  {
    "id": "adk_example_4-structured-outputs",
    "content": "# Structured Outputs in ADK\n\nThis example demonstrates how to implement structured outputs in the Agent Development Kit (ADK) using Pydantic models. The main agent in this example, `email_generator`, uses the `output_schema` parameter to ensure its responses conform to a specific structured format.\n\n## What are Structured Outputs?\n\nADK allows you to define structured data formats for agent inputs and outputs using Pydantic models:\n\n1. **Controlled Output Format**: Using `output_schema` ensures the LLM produces responses in a consistent JSON structure\n2. **Data Validation**: Pydantic validates that all required fields are present and correctly formatted\n3. **Improved Downstream Processing**: Structured outputs are easier to handle in downstream applications or by other agents\n\nUse structured outputs when you need guaranteed format consistency for integration with other systems or agents.\n\n## Email Generator Example\n\nIn this example, we've created an email generator agent that produces structured output with:\n\n1. **Email Subject**: A concise, relevant subject line\n2. **Email Body**: Well-formatted email content with greeting, paragraphs, and signature\n\nThe agent uses a Pydantic model called `EmailContent` to define this structure, ensuring every response follows the same format.\n\n### Output Schema Definition\n\nThe Pydantic model defines exactly what fields are required and includes descriptions for each:\n\n```python\nclass EmailContent(BaseModel):\n    \"\"\"Schema for email content with subject and body.\"\"\"\n    \n    subject: str = Field(\n        description=\"The subject line of the email. Should be concise and descriptive.\"\n    )\n    body: str = Field(\n        description=\"The main content of the email. Should be well-formatted with proper greeting, paragraphs, and signature.\"\n    )\n```\n\n### How It Works\n\n1. The user provides a description of the email they need\n2. The LLM agent processes this request and generates both a subject and body\n3. The agent formats its response as a JSON object matching the `EmailContent` schema\n4. ADK validates the response against the schema before returning it\n5. The structured output is stored in the session state under the specified `output_key`\n\n## Important Limitations\n\nWhen using `output_schema`:\n\n1. **No Tool Usage**: Agents with an output schema cannot use tools during their execution\n2. **Direct JSON Response**: The LLM must produce a JSON response matching the schema as its final output\n3. **Clear Instructions**: The agent's instructions must explicitly guide the LLM to produce properly formatted JSON\n\n## Project Structure\n\n```\n4-structured-outputs/\n│\n├── email_agent/                   # Email Generator Agent package\n│   └── agent.py                   # Agent definition with output schema\n│\n└── README.md                      # This documentation\n```\n\n## Getting Started\n\n### Setup\n\n1. Activate the virtual environment from the root directory:\n```bash\n# macOS/Linux:\nsource ../.venv/bin/activate\n# Windows CMD:\n..\\.venv\\Scripts\\activate.bat\n# Windows PowerShell:\n..\\.venv\\Scripts\\Activate.ps1\n```\n\n2. Create a `.env` file and add your Google API key:\n```\nGOOGLE_API_KEY=your_api_key_here\n```\n\n### Running the Example\n\n```bash\ncd 4-structured-outputs\nadk web\n```\n\nThen select \"email_generator\" from the dropdown menu in the web UI.\n\n## Example Interactions\n\nTry these example prompts:\n\n```\nWrite a professional email to my team about the upcoming project deadline that has been extended by two weeks.\n```\n\n```\nDraft an email to a client explaining that we need additional information before we can proceed with their order.\n```\n\n```\nCreate an email to schedule a meeting with the marketing department to discuss the new product launch strategy.\n```\n\n## Key Concepts: Structured Data Exchange\n\nStructured outputs are part of ADK's broader support for structured data exchange, which includes:\n\n1. **input_schema**: Define expected input format (not used in this example)\n2. **output_schema**: Define required output format (used in this example)\n3. **output_key**: Store the result in session state for use by other agents (used in this example)\n\nThis pattern enables reliable data passing between agents and integration with external systems that expect consistent data formats.\n\n## Additional Resources\n\n- [ADK Structured Data Documentation](https://google.github.io/adk-docs/agents/llm-agents/#structuring-data-input_schema-output_schema-output_key)\n- [Pydantic Documentation](https://docs.pydantic.dev/latest/) \n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "4-structured-outputs",
      "type": "documentation",
      "file": "README.md",
      "indexed_at": "2025-07-22T14:24:19.165167"
    },
    "displayName": "ADK Example: 4-structured-outputs (documentation)"
  },
  {
    "id": "adk_code_9e8ddb45",
    "content": "# ADK Example: 4-structured-outputs\n# File: 4-structured-outputs/email_agent/agent.py\n\nfrom google.adk.agents import LlmAgent\nfrom pydantic import BaseModel, Field\n\n\n# --- Define Output Schema ---\nclass EmailContent(BaseModel):\n    subject: str = Field(\n        description=\"The subject line of the email. Should be concise and descriptive.\"\n    )\n    body: str = Field(\n        description=\"The main content of the email. Should be well-formatted with proper greeting, paragraphs, and signature.\"\n    )\n\n\n# --- Create Email Generator Agent ---\nroot_agent = LlmAgent(\n    name=\"email_agent\",\n    model=\"gemini-2.0-flash\",\n    instruction=\"\"\"\n        You are an Email Generation Assistant.\n        Your task is to generate a professional email based on the user's request.\n\n        GUIDELINES:\n        - Create an appropriate subject line (concise and relevant)\n        - Write a well-structured email body with:\n            * Professional greeting\n            * Clear and concise main content\n            * Appropriate closing\n            * Your name as signature\n        - Suggest relevant attachments if applicable (empty list if none needed)\n        - Email tone should match the purpose (formal for business, friendly for colleagues)\n        - Keep emails concise but complete\n\n        IMPORTANT: Your response MUST be valid JSON matching this structure:\n        {\n            \"subject\": \"Subject line here\",\n            \"body\": \"Email body here with proper paragraphs and formatting\",\n        }\n\n        DO NOT include any explanations or additional text outside the JSON response.\n    \"\"\",\n    description=\"Generates professional emails with structured subject and body\",\n    output_schema=EmailContent,\n    output_key=\"email\",\n)\n\n\n# This code demonstrates:\n# - ADK patterns for structured outputs\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "4-structured-outputs",
      "type": "code",
      "file": "4-structured-outputs/email_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.165272"
    },
    "displayName": "ADK Example: 4-structured-outputs (code)"
  },
  {
    "id": "adk_example_5-sessions-and-state",
    "content": "# Sessions and State Management in ADK\n\nThis example demonstrates how to create and manage stateful sessions in the Agent Development Kit (ADK), enabling your agents to maintain context and remember user information across interactions.\n\n## What Are Sessions in ADK?\n\nSessions in ADK provide a way to:\n\n1. **Maintain State**: Store and access user data, preferences, and other information between interactions\n2. **Track Conversation History**: Automatically record and retrieve message history\n3. **Personalize Responses**: Use stored information to create more contextual and personalized agent experiences\n\nUnlike simple conversational agents that forget previous interactions, stateful agents can build relationships with users over time by remembering important details and preferences.\n\n## Example Overview\n\nThis directory contains a basic stateful session example that demonstrates:\n\n- Creating a session with user preferences\n- Using template variables to access session state in agent instructions\n- Running the agent with a session to maintain context\n\nThe example uses a simple question-answering agent that responds based on stored user information in the session state.\n\n## Project Structure\n\n```\n5-sessions-and-state/\n│\n├── basic_stateful_session.py      # Main example script\n│\n└── question_answering_agent/      # Agent implementation\n    ├── __init__.py\n    └── agent.py                   # Agent definition with template variables\n```\n\n## Getting Started\n\n### Setup\n\n1. Activate the virtual environment from the root directory:\n```bash\n# macOS/Linux:\nsource ../.venv/bin/activate\n# Windows CMD:\n..\\.venv\\Scripts\\activate.bat\n# Windows PowerShell:\n..\\.venv\\Scripts\\Activate.ps1\n```\n\n2. Create a `.env` file and add your Google API key:\n```\nGOOGLE_API_KEY=your_api_key_here\n```\n\n### Running the Example\n\nRun the example to see a stateful session in action:\n\n```bash\npython basic_stateful_session.py\n```\n\nThis will:\n1. Create a new session with user information\n2. Initialize the agent with access to that session\n3. Process a user query about the stored preferences\n4. Display the agent's response based on the session data\n\n## Key Components\n\n### Session Service\n\nThe example uses the `InMemorySessionService` which stores sessions in memory:\n\n```python\nsession_service = InMemorySessionService()\n```\n\n### Initial State\n\nSessions are created with an initial state containing user information:\n\n```python\ninitial_state = {\n    \"user_name\": \"Brandon Hancock\",\n    \"user_preferences\": \"\"\"\n        I like to play Pickleball, Disc Golf, and Tennis.\n        My favorite food is Mexican.\n        My favorite TV show is Game of Thrones.\n        Loves it when people like and subscribe to his YouTube channel.\n    \"\"\",\n}\n```\n\n### Creating a Session\n\nThe example creates a session with a unique identifier:\n\n```python\nstateful_session = session_service.create_session(\n    app_name=APP_NAME,\n    user_id=USER_ID,\n    session_id=SESSION_ID,\n    state=initial_state,\n)\n```\n\n### Accessing State in Agent Instructions\n\nThe agent accesses session state using template variables in its instructions:\n\n```python\ninstruction=\"\"\"\nYou are a helpful assistant that answers questions about the user's preferences.\n\nHere is some information about the user:\nName: \n{user_name}\nPreferences: \n{user_preferences}\n\"\"\"\n```\n\n### Running with Sessions\n\nSessions are integrated with the `Runner` to maintain state between interactions:\n\n```python\nrunner = Runner(\n    agent=question_answering_agent,\n    app_name=APP_NAME,\n    session_service=session_service,\n)\n```\n\n## Additional Resources\n\n- [Google ADK Sessions Documentation](https://google.github.io/adk-docs/sessions/session/)\n- [State Management in ADK](https://google.github.io/adk-docs/sessions/state/)\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "5-sessions-and-state",
      "type": "documentation",
      "file": "README.md",
      "indexed_at": "2025-07-22T14:24:19.165343"
    },
    "displayName": "ADK Example: 5-sessions-and-state (documentation)"
  },
  {
    "id": "adk_code_5231a40b",
    "content": "# ADK Example: 5-sessions-and-state\n# File: 5-sessions-and-state/basic_stateful_session.py\n\nimport uuid\n\nfrom dotenv import load_dotenv\nfrom google.adk.runners import Runner\nfrom google.adk.sessions import InMemorySessionService\nfrom google.genai import types\nfrom question_answering_agent import question_answering_agent\n\nload_dotenv()\n\n\n# Create a new session service to store state\nsession_service_stateful = InMemorySessionService()\n\ninitial_state = {\n    \"user_name\": \"Brandon Hancock\",\n    \"user_preferences\": \"\"\"\n        I like to play Pickleball, Disc Golf, and Tennis.\n        My favorite food is Mexican.\n        My favorite TV show is Game of Thrones.\n        Loves it when people like and subscribe to his YouTube channel.\n    \"\"\",\n}\n\n# Create a NEW session\nAPP_NAME = \"Brandon Bot\"\nUSER_ID = \"brandon_hancock\"\nSESSION_ID = str(uuid.uuid4())\nstateful_session = session_service_stateful.create_session(\n    app_name=APP_NAME,\n    user_id=USER_ID,\n    session_id=SESSION_ID,\n    state=initial_state,\n)\nprint(\"CREATED NEW SESSION:\")\nprint(f\"\\tSession ID: {SESSION_ID}\")\n\nrunner = Runner(\n    agent=question_answering_agent,\n    app_name=APP_NAME,\n    session_service=session_service_stateful,\n)\n\nnew_message = types.Content(\n    role=\"user\", parts=[types.Part(text=\"What is Brandon's favorite TV show?\")]\n)\n\nfor event in runner.run(\n    user_id=USER_ID,\n    session_id=SESSION_ID,\n    new_message=new_message,\n):\n    if event.is_final_response():\n        if event.content and event.content.parts:\n            print(f\"Final Response: {event.content.parts[0].text}\")\n\nprint(\"==== Session Event Exploration ====\")\nsession = session_service_stateful.get_session(\n    app_name=APP_NAME, user_id=USER_ID, session_id=SESSION_ID\n)\n\n# Log final Session state\nprint(\"=== Final Session State ===\")\nfor key, value in session.state.items():\n    print(f\"{key}: {value}\")\n\n\n# This code demonstrates:\n# - ADK patterns for sessions and state\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "5-sessions-and-state",
      "type": "code",
      "file": "5-sessions-and-state/basic_stateful_session.py",
      "indexed_at": "2025-07-22T14:24:19.165505"
    },
    "displayName": "ADK Example: 5-sessions-and-state (code)"
  },
  {
    "id": "adk_code_5984af66",
    "content": "# ADK Example: 5-sessions-and-state\n# File: 5-sessions-and-state/question_answering_agent/agent.py\n\nfrom google.adk.agents import Agent\n\n# Create the root agent\nquestion_answering_agent = Agent(\n    name=\"question_answering_agent\",\n    model=\"gemini-2.0-flash\",\n    description=\"Question answering agent\",\n    instruction=\"\"\"\n    You are a helpful assistant that answers questions about the user's preferences.\n\n    Here is some information about the user:\n    Name: \n    {user_name}\n    Preferences: \n    {user_preferences}\n    \"\"\",\n)\n\n\n# This code demonstrates:\n# - ADK patterns for sessions and state\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "5-sessions-and-state",
      "type": "code",
      "file": "5-sessions-and-state/question_answering_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.165584"
    },
    "displayName": "ADK Example: 5-sessions-and-state (code)"
  },
  {
    "id": "adk_example_6-persistent-storage",
    "content": "# Persistent Storage in ADK\n\nThis example demonstrates how to implement persistent storage for your ADK agents, allowing them to remember information and maintain conversation history across multiple sessions, application restarts, and even server deployments.\n\n## What is Persistent Storage in ADK?\n\nIn previous examples, we used `InMemorySessionService` which stores session data only in memory - this data is lost when the application stops. For real-world applications, you'll often need your agents to remember user information and conversation history long-term. This is where persistent storage comes in.\n\nADK provides the `DatabaseSessionService` that allows you to store session data in a SQL database, ensuring:\n\n1. **Long-term Memory**: Information persists across application restarts\n2. **Consistent User Experiences**: Users can continue conversations where they left off\n3. **Multi-user Support**: Different users' data remains separate and secure\n4. **Scalability**: Works with production databases for high-scale deployments\n\nThis example shows how to implement a reminder agent that remembers your name and todos across different conversations using an SQLite database.\n\n## Project Structure\n\n```\n5-persistent-storage/\n│\n├── memory_agent/               # Agent package\n│   ├── __init__.py             # Required for ADK to discover the agent\n│   └── agent.py                # Agent definition with reminder tools\n│\n├── main.py                     # Application entry point with database session setup\n├── utils.py                    # Utility functions for terminal UI and agent interaction\n├── .env                        # Environment variables\n├── my_agent_data.db            # SQLite database file (created when first run)\n└── README.md                   # This documentation\n```\n\n## Key Components\n\n### 1. DatabaseSessionService\n\nThe core component that provides persistence is the `DatabaseSessionService`, which is initialized with a database URL:\n\n```python\nfrom google.adk.sessions import DatabaseSessionService\n\ndb_url = \"sqlite:///./my_agent_data.db\"\nsession_service = DatabaseSessionService(db_url=db_url)\n```\n\nThis service allows ADK to:\n- Store session data in a SQLite database file\n- Retrieve previous sessions for a user\n- Automatically manage database schemas\n\n### 2. Session Management\n\nThe example demonstrates proper session management:\n\n```python\n# Check for existing sessions for this user\nexisting_sessions = session_service.list_sessions(\n    app_name=APP_NAME,\n    user_id=USER_ID,\n)\n\n# If there's an existing session, use it, otherwise create a new one\nif existing_sessions and len(existing_sessions.sessions) > 0:\n    # Use the most recent session\n    SESSION_ID = existing_sessions.sessions[0].id\n    print(f\"Continuing existing session: {SESSION_ID}\")\nelse:\n    # Create a new session with initial state\n    session_service.create_session(\n        app_name=APP_NAME,\n        user_id=USER_ID,\n        session_id=SESSION_ID,\n        state=initialize_state(),\n    )\n```\n\n### 3. State Management with Tools\n\nThe agent includes tools that update the persistent state:\n\n```python\ndef add_reminder(reminder: str, tool_context: ToolContext) -> dict:\n    # Get current reminders from state\n    reminders = tool_context.state.get(\"reminders\", [])\n    \n    # Add the new reminder\n    reminders.append(reminder)\n    \n    # Update state with the new list of reminders\n    tool_context.state[\"reminders\"] = reminders\n    \n    return {\n        \"action\": \"add_reminder\",\n        \"reminder\": reminder,\n        \"message\": f\"Added reminder: {reminder}\",\n    }\n```\n\nEach change to `tool_context.state` is automatically saved to the database.\n\n## Getting Started\n\n### Prerequisites\n\n- Python 3.9+\n- Google API Key for Gemini models\n- SQLite (included with Python)\n\n### Setup\n\n1. Activate the virtual environment from the root directory:\n```bash\n# macOS/Linux:\nsource ../.venv/bin/activate\n# Windows CMD:\n..\\.venv\\Scripts\\activate.bat\n# Windows PowerShell:\n..\\.venv\\Scripts\\Activate.ps1\n```\n\n2. Make sure your Google API key is set in the `.env` file:\n```\nGOOGLE_API_KEY=your_api_key_here\n```\n\n### Running the Example\n\nTo run the persistent storage example:\n\n```bash\npython main.py\n```\n\nThis will:\n1. Connect to the SQLite database (or create it if it doesn't exist)\n2. Check for previous sessions for the user\n3. Start a conversation with the memory agent\n4. Save all interactions to the database\n\n### Example Interactions\n\nTry these interactions to test the agent's persistent memory:\n\n1. **First run:**\n   - \"What's my name?\"\n   - \"My name is John\"\n   - \"Add a reminder to buy groceries\"\n   - \"Add another reminder to finish the report\"\n   - \"What are my reminders?\"\n   - Exit the program with \"exit\"\n\n2. **Second run:**\n   - \"What's my name?\"\n   - \"What reminders do I have?\"\n   - \"Update my second reminder to submit the report by Friday\"\n   - \"Delete the first reminder\"\n   \nThe agent will remember your name and reminders between runs!\n\n## Using Database Storage in Production\n\nWhile this example uses SQLite for simplicity, `DatabaseSessionService` supports various database backends through SQLAlchemy:\n\n- PostgreSQL: `postgresql://user:password@localhost/dbname`\n- MySQL: `mysql://user:password@localhost/dbname`\n- MS SQL Server: `mssql://user:password@localhost/dbname`\n\nFor production use:\n1. Choose a database system that meets your scalability needs\n2. Configure connection pooling for efficiency\n3. Implement proper security for database credentials\n4. Consider database backups for critical agent data\n\n## Additional Resources\n\n- [ADK Sessions Documentation](https://google.github.io/adk-docs/sessions/session/)\n- [Session Service Implementations](https://google.github.io/adk-docs/sessions/session/#sessionservice-implementations)\n- [State Management in ADK](https://google.github.io/adk-docs/sessions/state/)\n- [SQLAlchemy Documentation](https://docs.sqlalchemy.org/) for advanced database configuration \n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "6-persistent-storage",
      "type": "documentation",
      "file": "README.md",
      "indexed_at": "2025-07-22T14:24:19.165652"
    },
    "displayName": "ADK Example: 6-persistent-storage (documentation)"
  },
  {
    "id": "adk_code_189dbc9c",
    "content": "# ADK Example: 6-persistent-storage\n# File: 6-persistent-storage/utils.py\n\nfrom google.genai import types\n\n\n# ANSI color codes for terminal output\nclass Colors:\n    RESET = \"\\033[0m\"\n    BOLD = \"\\033[1m\"\n    UNDERLINE = \"\\033[4m\"\n\n    # Foreground colors\n    BLACK = \"\\033[30m\"\n    RED = \"\\033[31m\"\n    GREEN = \"\\033[32m\"\n    YELLOW = \"\\033[33m\"\n    BLUE = \"\\033[34m\"\n    MAGENTA = \"\\033[35m\"\n    CYAN = \"\\033[36m\"\n    WHITE = \"\\033[37m\"\n\n    # Background colors\n    BG_BLACK = \"\\033[40m\"\n    BG_RED = \"\\033[41m\"\n    BG_GREEN = \"\\033[42m\"\n    BG_YELLOW = \"\\033[43m\"\n    BG_BLUE = \"\\033[44m\"\n    BG_MAGENTA = \"\\033[45m\"\n    BG_CYAN = \"\\033[46m\"\n    BG_WHITE = \"\\033[47m\"\n\n\ndef display_state(\n    session_service, app_name, user_id, session_id, label=\"Current State\"\n):\n    \"\"\"Display the current session state in a formatted way.\"\"\"\n    try:\n        session = session_service.get_session(\n            app_name=app_name, user_id=user_id, session_id=session_id\n        )\n\n        # Format the output with clear sections\n        print(f\"\\n{'-' * 10} {label} {'-' * 10}\")\n\n        # Handle the user name\n        user_name = session.state.get(\"user_name\", \"Unknown\")\n        print(f\"👤 User: {user_name}\")\n\n        # Handle reminders\n        reminders = session.state.get(\"reminders\", [])\n        if reminders:\n            print(\"📝 Reminders:\")\n            for idx, reminder in enumerate(reminders, 1):\n                print(f\"  {idx}. {reminder}\")\n        else:\n            print(\"📝 Reminders: None\")\n\n        print(\"-\" * (22 + len(label)))\n    except Exception as e:\n        print(f\"Error displaying state: {e}\")\n\n\nasync def process_agent_response(event):\n    \"\"\"Process and display agent response events.\"\"\"\n    # Log basic event info\n    print(f\"Event ID: {event.id}, Author: {event.author}\")\n\n    # Check for specific parts first\n    has_specific_part = False\n    if event.content and event.content.parts:\n        for part in event.content.parts:\n            if hasattr(part, \"executable_code\") and part.executable_code:\n                # Access the actual code string via .code\n                print(\n                    f\"  Debug: Agent generated code:\\n```python\\n{part.executable_code.code}\\n```\"\n                )\n                has_specific_part = True\n            elif hasattr(part, \"code_execution_result\") and part.code_execution_result:\n                # Access outcome and output correctly\n                print(\n                    f\"  Debug: Code Execution Result: {part.code_execution_result.outcome} - Output:\\n{part.code_execution_result.output}\"\n                )\n                has_specific_part = True\n            elif hasattr(part, \"tool_response\") and part.tool_response:\n                # Print tool response information\n                print(f\"  Tool Response: {part.tool_response.output}\")\n                has_specific_part = True\n            # Also print any text parts found in any event for debugging\n            elif hasattr(part, \"text\") and part.text and not part.text.isspace():\n                print(f\"  Text: '{part.text.strip()}'\")\n\n    # Check for final response after specific parts\n    final_response = None\n    if event.is_final_response():\n        if (\n            event.content\n            and event.content.parts\n            and hasattr(event.content.parts[0], \"text\")\n            and event.content.parts[0].text\n        ):\n            final_response = event.content.parts[0].text.strip()\n            # Use colors and formatting to make the final response stand out\n            print(\n                f\"\\n{Colors.BG_BLUE}{Colors.WHITE}{Colors.BOLD}╔══ AGENT RESPONSE ═════════════════════════════════════════{Colors.RESET}\"\n            )\n            print(f\"{Colors.CYAN}{Colors.BOLD}{final_response}{Colors.RESET}\")\n            print(\n                f\"{Colors.BG_BLUE}{Colors.WHITE}{Colors.BOLD}╚═════════════════════════════════════════════════════════════{Colors.RESET}\\n\"\n            )\n        else:\n            print(\n                f\"\\n{Colors.BG_RED}{Colors.WHITE}{Colors.BOLD}==> Final Agent Response: [No text content in final event]{Colors.RESET}\\n\"\n            )\n\n    return final_response\n\n\nasync def call_agent_async(runner, user_id, session_id, query):\n    \"\"\"Call the agent asynchronously with the user's query.\"\"\"\n    content = types.Content(role=\"user\", parts=[types.Part(text=query)])\n    print(\n        f\"\\n{Colors.BG_GREEN}{Colors.BLACK}{Colors.BOLD}--- Running Query: {query} ---{Colors.RESET}\"\n    )\n    final_response_text = None\n\n    # Display state before processing\n    display_state(\n        runner.session_service,\n        runner.app_name,\n        user_id,\n        session_id,\n        \"State BEFORE processing\",\n    )\n\n    try:\n        async for event in runner.run_async(\n            user_id=user_id, session_id=session_id, new_message=content\n        ):\n            # Process each event and get the final response if available\n            response = await process_agent_response(event)\n            if response:\n                final_response_text = response\n    except Exception as e:\n        print(f\"Error during agent call: {e}\")\n\n    # Display state after processing the message\n    display_state(\n        runner.session_service,\n        runner.app_name,\n        user_id,\n        session_id,\n        \"State AFTER processing\",\n    )\n\n    return final_response_text\n\n\n# This code demonstrates:\n# - ADK patterns for persistent storage\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "6-persistent-storage",
      "type": "code",
      "file": "6-persistent-storage/utils.py",
      "indexed_at": "2025-07-22T14:24:19.165728"
    },
    "displayName": "ADK Example: 6-persistent-storage (code)"
  },
  {
    "id": "adk_code_3aa3f2d4",
    "content": "# ADK Example: 6-persistent-storage\n# File: 6-persistent-storage/main.py\n\nimport asyncio\n\nfrom dotenv import load_dotenv\nfrom google.adk.runners import Runner\nfrom google.adk.sessions import DatabaseSessionService\nfrom memory_agent.agent import memory_agent\nfrom utils import call_agent_async\n\nload_dotenv()\n\n# ===== PART 1: Initialize Persistent Session Service =====\n# Using SQLite database for persistent storage\ndb_url = \"sqlite:///./my_agent_data.db\"\nsession_service = DatabaseSessionService(db_url=db_url)\n\n\n# ===== PART 2: Define Initial State =====\n# This will only be used when creating a new session\ninitial_state = {\n    \"user_name\": \"Brandon Hancock\",\n    \"reminders\": [],\n}\n\n\nasync def main_async():\n    # Setup constants\n    APP_NAME = \"Memory Agent\"\n    USER_ID = \"aiwithbrandon\"\n\n    # ===== PART 3: Session Management - Find or Create =====\n    # Check for existing sessions for this user\n    existing_sessions = session_service.list_sessions(\n        app_name=APP_NAME,\n        user_id=USER_ID,\n    )\n\n    # If there's an existing session, use it, otherwise create a new one\n    if existing_sessions and len(existing_sessions.sessions) > 0:\n        # Use the most recent session\n        SESSION_ID = existing_sessions.sessions[0].id\n        print(f\"Continuing existing session: {SESSION_ID}\")\n    else:\n        # Create a new session with initial state\n        new_session = session_service.create_session(\n            app_name=APP_NAME,\n            user_id=USER_ID,\n            state=initial_state,\n        )\n        SESSION_ID = new_session.id\n        print(f\"Created new session: {SESSION_ID}\")\n\n    # ===== PART 4: Agent Runner Setup =====\n    # Create a runner with the memory agent\n    runner = Runner(\n        agent=memory_agent,\n        app_name=APP_NAME,\n        session_service=session_service,\n    )\n\n    # ===== PART 5: Interactive Conversation Loop =====\n    print(\"\\nWelcome to Memory Agent Chat!\")\n    print(\"Your reminders will be remembered across conversations.\")\n    print(\"Type 'exit' or 'quit' to end the conversation.\\n\")\n\n    while True:\n        # Get user input\n        user_input = input(\"You: \")\n\n        # Check if user wants to exit\n        if user_input.lower() in [\"exit\", \"quit\"]:\n            print(\"Ending conversation. Your data has been saved to the database.\")\n            break\n\n        # Process the user query through the agent\n        await call_agent_async(runner, USER_ID, SESSION_ID, user_input)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main_async())\n\n\n# This code demonstrates:\n# - ADK patterns for persistent storage\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "6-persistent-storage",
      "type": "code",
      "file": "6-persistent-storage/main.py",
      "indexed_at": "2025-07-22T14:24:19.165775"
    },
    "displayName": "ADK Example: 6-persistent-storage (code)"
  },
  {
    "id": "adk_code_f981506d",
    "content": "# ADK Example: 6-persistent-storage\n# File: 6-persistent-storage/memory_agent/agent.py\n\nfrom google.adk.agents import Agent\nfrom google.adk.tools.tool_context import ToolContext\n\n\ndef add_reminder(reminder: str, tool_context: ToolContext) -> dict:\n    \"\"\"Add a new reminder to the user's reminder list.\n\n    Args:\n        reminder: The reminder text to add\n        tool_context: Context for accessing and updating session state\n\n    Returns:\n        A confirmation message\n    \"\"\"\n    print(f\"--- Tool: add_reminder called for '{reminder}' ---\")\n\n    # Get current reminders from state\n    reminders = tool_context.state.get(\"reminders\", [])\n\n    # Add the new reminder\n    reminders.append(reminder)\n\n    # Update state with the new list of reminders\n    tool_context.state[\"reminders\"] = reminders\n\n    return {\n        \"action\": \"add_reminder\",\n        \"reminder\": reminder,\n        \"message\": f\"Added reminder: {reminder}\",\n    }\n\n\ndef view_reminders(tool_context: ToolContext) -> dict:\n    \"\"\"View all current reminders.\n\n    Args:\n        tool_context: Context for accessing session state\n\n    Returns:\n        The list of reminders\n    \"\"\"\n    print(\"--- Tool: view_reminders called ---\")\n\n    # Get reminders from state\n    reminders = tool_context.state.get(\"reminders\", [])\n\n    return {\"action\": \"view_reminders\", \"reminders\": reminders, \"count\": len(reminders)}\n\n\ndef update_reminder(index: int, updated_text: str, tool_context: ToolContext) -> dict:\n    \"\"\"Update an existing reminder.\n\n    Args:\n        index: The 1-based index of the reminder to update\n        updated_text: The new text for the reminder\n        tool_context: Context for accessing and updating session state\n\n    Returns:\n        A confirmation message\n    \"\"\"\n    print(\n        f\"--- Tool: update_reminder called for index {index} with '{updated_text}' ---\"\n    )\n\n    # Get current reminders from state\n    reminders = tool_context.state.get(\"reminders\", [])\n\n    # Check if the index is valid\n    if not reminders or index < 1 or index > len(reminders):\n        return {\n            \"action\": \"update_reminder\",\n            \"status\": \"error\",\n            \"message\": f\"Could not find reminder at position {index}. Currently there are {len(reminders)} reminders.\",\n        }\n\n    # Update the reminder (adjusting for 0-based indices)\n    old_reminder = reminders[index - 1]\n    reminders[index - 1] = updated_text\n\n    # Update state with the modified list\n    tool_context.state[\"reminders\"] = reminders\n\n    return {\n        \"action\": \"update_reminder\",\n        \"index\": index,\n        \"old_text\": old_reminder,\n        \"updated_text\": updated_text,\n        \"message\": f\"Updated reminder {index} from '{old_reminder}' to '{updated_text}'\",\n    }\n\n\ndef delete_reminder(index: int, tool_context: ToolContext) -> dict:\n    \"\"\"Delete a reminder.\n\n    Args:\n        index: The 1-based index of the reminder to delete\n        tool_context: Context for accessing and updating session state\n\n    Returns:\n        A confirmation message\n    \"\"\"\n    print(f\"--- Tool: delete_reminder called for index {index} ---\")\n\n    # Get current reminders from state\n    reminders = tool_context.state.get(\"reminders\", [])\n\n    # Check if the index is valid\n    if not reminders or index < 1 or index > len(reminders):\n        return {\n            \"action\": \"delete_reminder\",\n            \"status\": \"error\",\n            \"message\": f\"Could not find reminder at position {index}. Currently there are {len(reminders)} reminders.\",\n        }\n\n    # Remove the reminder (adjusting for 0-based indices)\n    deleted_reminder = reminders.pop(index - 1)\n\n    # Update state with the modified list\n    tool_context.state[\"reminders\"] = reminders\n\n    return {\n        \"action\": \"delete_reminder\",\n        \"index\": index,\n        \"deleted_reminder\": deleted_reminder,\n        \"message\": f\"Deleted reminder {index}: '{deleted_reminder}'\",\n    }\n\n\ndef update_user_name(name: str, tool_context: ToolContext) -> dict:\n    \"\"\"Update the user's name.\n\n    Args:\n        name: The new name for the user\n        tool_context: Context for accessing and updating session state\n\n    Returns:\n        A confirmation message\n    \"\"\"\n    print(f\"--- Tool: update_user_name called with '{name}' ---\")\n\n    # Get current name from state\n    old_name = tool_context.state.get(\"user_name\", \"\")\n\n    # Update the name in state\n    tool_context.state[\"user_name\"] = name\n\n    return {\n        \"action\": \"update_user_name\",\n        \"old_name\": old_name,\n        \"new_name\": name,\n        \"message\": f\"Updated your name to: {name}\",\n    }\n\n\n# Create a simple persistent agent\nmemory_agent = Agent(\n    name=\"memory_agent\",\n    model=\"gemini-2.0-flash\",\n    description=\"A smart reminder agent with persistent memory\",\n    instruction=\"\"\"\n    You are a friendly reminder assistant that remembers users across conversations.\n    \n    The user's information is stored in state:\n    - User's name: {user_name}\n    - Reminders: {reminders}\n    \n    You can help users manage their reminders with the following capabilities:\n    1. Add new reminders\n    2. View existing reminders\n    3. Update reminders\n    4. Delete reminders\n    5. Update the user's name\n    \n    Always be friendly and address the user by name. If you don't know their name yet,\n    use the update_user_name tool to store it when they introduce themselves.\n    \n    **REMINDER MANAGEMENT GUIDELINES:**\n    \n    When dealing with reminders, you need to be smart about finding the right reminder:\n    \n    1. When the user asks to update or delete a reminder but doesn't provide an index:\n       - If they mention the content of the reminder (e.g., \"delete my meeting reminder\"), \n         look through the reminders to find a match\n       - If you find an exact or close match, use that index\n       - Never clarify which reminder the user is referring to, just use the first match\n       - If no match is found, list all reminders and ask the user to specify\n    \n    2. When the user mentions a number or position:\n       - Use that as the index (e.g., \"delete reminder 2\" means index=2)\n       - Remember that indexing starts at 1 for the user\n    \n    3. For relative positions:\n       - Handle \"first\", \"last\", \"second\", etc. appropriately\n       - \"First reminder\" = index 1\n       - \"Last reminder\" = the highest index\n       - \"Second reminder\" = index 2, and so on\n    \n    4. For viewing:\n       - Always use the view_reminders tool when the user asks to see their reminders\n       - Format the response in a numbered list for clarity\n       - If there are no reminders, suggest adding some\n    \n    5. For addition:\n       - Extract the actual reminder text from the user's request\n       - Remove phrases like \"add a reminder to\" or \"remind me to\"\n       - Focus on the task itself (e.g., \"add a reminder to buy milk\" → add_reminder(\"buy milk\"))\n    \n    6. For updates:\n       - Identify both which reminder to update and what the new text should be\n       - For example, \"change my second reminder to pick up groceries\" → update_reminder(2, \"pick up groceries\")\n    \n    7. For deletions:\n       - Confirm deletion when complete and mention which reminder was removed\n       - For example, \"I've deleted your reminder to 'buy milk'\"\n    \n    Remember to explain that you can remember their information across conversations.\n\n    IMPORTANT:\n    - use your best judgement to determine which reminder the user is referring to. \n    - You don't have to be 100% correct, but try to be as close as possible.\n    - Never ask the user to clarify which reminder they are referring to.\n    \"\"\",\n    tools=[\n        add_reminder,\n        view_reminders,\n        update_reminder,\n        delete_reminder,\n        update_user_name,\n    ],\n)\n\n\n# This code demonstrates:\n# - ADK patterns for persistent storage\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "6-persistent-storage",
      "type": "code",
      "file": "6-persistent-storage/memory_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.165860"
    },
    "displayName": "ADK Example: 6-persistent-storage (code)"
  },
  {
    "id": "adk_example_7-multi-agent",
    "content": "# Multi-Agent Systems in ADK\n\nThis example demonstrates how to create a multi-agent system in ADK, where specialized agents collaborate to handle complex tasks, each focusing on their area of expertise.\n\n## What is a Multi-Agent System?\n\nA Multi-Agent System is an advanced pattern in the Agent Development Kit (ADK) that allows multiple specialized agents to work together to handle complex tasks. Each agent can focus on a specific domain or functionality, and they can collaborate through delegation and communication to solve problems that would be difficult for a single agent.\n\n## Project Structure Requirements\n\nFor multi-agent systems to work properly with ADK, your project must follow a specific structure:\n\n```\nparent_folder/\n├── root_agent_folder/           # Main agent package (e.g., \"manager\")\n│   ├── __init__.py              # Must import agent.py\n│   ├── agent.py                 # Must define root_agent\n│   ├── .env                     # Environment variables\n│   └── sub_agents/              # Directory for all sub-agents\n│       ├── __init__.py          # Empty or imports sub-agents\n│       ├── agent_1_folder/      # Sub-agent package\n│       │   ├── __init__.py      # Must import agent.py\n│       │   └── agent.py         # Must define an agent variable\n│       ├── agent_2_folder/\n│       │   ├── __init__.py\n│       │   └── agent.py\n│       └── ...\n```\n\n### Essential Structure Components:\n\n1. **Root Agent Package**\n   - Must have the standard agent structure (like in the basic agent example)\n   - The `agent.py` file must define a `root_agent` variable\n\n2. **Sub-agents Directory**\n   - Typically organized as a directory called `sub_agents` inside the root agent folder\n   - Each sub-agent should be in its own directory following the same structure as regular agents\n\n3. **Importing Sub-agents**\n   - Root agent must import sub-agents to use them:\n   ```python\n   from .sub_agents.funny_nerd.agent import funny_nerd\n   from .sub_agents.stock_analyst.agent import stock_analyst\n   ```\n\n4. **Command Location**\n   - Always run `adk web` from the parent directory (`6-multi-agent`), not from inside any agent directory\n\nThis structure ensures that ADK can discover and correctly load all agents in the hierarchy.\n\n## Multi-Agent Architecture Options\n\nADK offers two primary approaches to building multi-agent systems:\n\n### 1. Sub-Agent Delegation Model\n\nUsing the `sub_agents` parameter, the root agent can fully delegate tasks to specialized agents:\n\n```python\nroot_agent = Agent(\n    name=\"manager\",\n    model=\"gemini-2.0-flash\",\n    description=\"Manager agent\",\n    instruction=\"You are a manager agent that delegates tasks to specialized agents...\",\n    sub_agents=[stock_analyst, funny_nerd],\n)\n```\n\n**Characteristics:**\n- Complete delegation - sub-agent takes over the entire response\n- The sub-agent decision is final and takes control of the conversation\n- Root agent acts as a \"router\" determining which specialist should handle the query\n\n### 2. Agent-as-a-Tool Model\n\nUsing the `AgentTool` wrapper, agents can be used as tools by other agents:\n\n```python\nfrom google.adk.tools.agent_tool import AgentTool\n\nroot_agent = Agent(\n    name=\"manager\",\n    model=\"gemini-2.0-flash\",\n    description=\"Manager agent\",\n    instruction=\"You are a manager agent that uses specialized agents as tools...\",\n    tools=[\n        AgentTool(news_analyst),\n        get_current_time,\n    ],\n)\n```\n\n**Characteristics:**\n- Sub-agent returns results to the root agent\n- Root agent maintains control and can incorporate the sub-agent's response into its own\n- Multiple tool calls can be made to different agent tools in a single response\n- Gives the root agent more flexibility in how it uses the results\n\n## Limitations When Using Multi-Agents\n\n### Sub-agent Restrictions\n\n**Built-in tools cannot be used within a sub-agent.**\n\nFor example, this approach using built-in tools within sub-agents is **not** currently supported:\n\n```python\nsearch_agent = Agent(\n    model='gemini-2.0-flash',\n    name='SearchAgent',\n    instruction=\"You're a specialist in Google Search\",\n    tools=[google_search],  # Built-in tool\n)\ncoding_agent = Agent(\n    model='gemini-2.0-flash',\n    name='CodeAgent',\n    instruction=\"You're a specialist in Code Execution\",\n    tools=[built_in_code_execution],  # Built-in tool\n)\nroot_agent = Agent(\n    name=\"RootAgent\",\n    model=\"gemini-2.0-flash\",\n    description=\"Root Agent\",\n    sub_agents=[\n        search_agent,  # NOT SUPPORTED\n        coding_agent   # NOT SUPPORTED\n    ],\n)\n```\n\n### Workaround Using Agent Tools\n\nTo use multiple built-in tools or to combine built-in tools with other tools, you can use the `AgentTool` approach:\n\n```python\nfrom google.adk.tools import agent_tool\n\nsearch_agent = Agent(\n    model='gemini-2.0-flash',\n    name='SearchAgent',\n    instruction=\"You're a specialist in Google Search\",\n    tools=[google_search],\n)\ncoding_agent = Agent(\n    model='gemini-2.0-flash',\n    name='CodeAgent',\n    instruction=\"You're a specialist in Code Execution\",\n    tools=[built_in_code_execution],\n)\nroot_agent = Agent(\n    name=\"RootAgent\",\n    model=\"gemini-2.0-flash\",\n    description=\"Root Agent\",\n    tools=[\n        agent_tool.AgentTool(agent=search_agent), \n        agent_tool.AgentTool(agent=coding_agent)\n    ],\n)\n```\n\nThis approach wraps agents as tools, allowing the root agent to delegate to specialized agents that each use a single built-in tool.\n\n## Our Multi-Agent Example\n\nThis example implements a manager agent that works with three specialized agents:\n\n1. **Stock Analyst** (Sub-agent): Provides financial information and stock market insights\n2. **Funny Nerd** (Sub-agent): Creates nerdy jokes about technical topics\n3. **News Analyst** (Agent Tool): Gives summaries of current technology news\n\nThe manager agent routes queries to the appropriate specialist based on the content of the user's request.\n\n## Getting Started\n\nThis example uses the same virtual environment created in the root directory. Make sure you have:\n\n1. Activated the virtual environment from the root directory:\n```bash\n# macOS/Linux:\nsource ../.venv/bin/activate\n# Windows CMD:\n..\\.venv\\Scripts\\activate.bat\n# Windows PowerShell:\n..\\.venv\\Scripts\\Activate.ps1\n```\n\n2. Set up your API key:\n   - Rename `.env.example` to `.env` in the manager folder\n   - Add your Google API key to the `GOOGLE_API_KEY` variable in the `.env` file\n\n## Running the Example\n\nTo run the multi-agent example:\n\n1. Navigate to the 6-multi-agent directory containing your agent folders.\n\n2. Start the interactive web UI:\n```bash\nadk web\n```\n\n3. Access the web UI by opening the URL shown in your terminal (typically http://localhost:8000)\n\n4. Select the \"manager\" agent from the dropdown menu in the top-left corner of the UI\n\n5. Start chatting with your agent in the textbox at the bottom of the screen\n\n### Troubleshooting\n\nIf your multi-agent setup doesn't appear properly in the dropdown menu:\n- Make sure you're running `adk web` from the parent directory (6-multi-agent)\n- Verify that each agent's `__init__.py` properly imports its respective `agent.py`\n- Check that the root agent properly imports all sub-agents\n\n### Example Prompts to Try\n\n- \"Can you tell me about the stock market today?\"\n- \"Tell me something funny about programming\"\n- \"What's the latest tech news?\"\n- \"What time is it right now?\"\n\nYou can exit the conversation or stop the server by pressing `Ctrl+C` in your terminal.\n\n## Additional Resources\n\n- [ADK Multi-Agent Systems Documentation](https://google.github.io/adk-docs/agents/multi-agent-systems/)\n- [Agent Tools Documentation](https://google.github.io/adk-docs/tools/function-tools/#3-agent-as-a-tool)\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "7-multi-agent",
      "type": "documentation",
      "file": "README.md",
      "indexed_at": "2025-07-22T14:24:19.166019"
    },
    "displayName": "ADK Example: 7-multi-agent (documentation)"
  },
  {
    "id": "adk_code_ec265653",
    "content": "# ADK Example: 7-multi-agent\n# File: 7-multi-agent/manager/agent.py\n\nfrom google.adk.agents import Agent\nfrom google.adk.tools.agent_tool import AgentTool\n\nfrom .sub_agents.funny_nerd.agent import funny_nerd\nfrom .sub_agents.news_analyst.agent import news_analyst\nfrom .sub_agents.stock_analyst.agent import stock_analyst\nfrom .tools.tools import get_current_time\n\nroot_agent = Agent(\n    name=\"manager\",\n    model=\"gemini-2.0-flash\",\n    description=\"Manager agent\",\n    instruction=\"\"\"\n    You are a manager agent that is responsible for overseeing the work of the other agents.\n\n    Always delegate the task to the appropriate agent. Use your best judgement \n    to determine which agent to delegate to.\n\n    You are responsible for delegating tasks to the following agent:\n    - stock_analyst\n    - funny_nerd\n\n    You also have access to the following tools:\n    - news_analyst\n    - get_current_time\n    \"\"\",\n    sub_agents=[stock_analyst, funny_nerd],\n    tools=[\n        AgentTool(news_analyst),\n        get_current_time,\n    ],\n)\n\n\n# This code demonstrates:\n# - ADK patterns for multi agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "7-multi-agent",
      "type": "code",
      "file": "7-multi-agent/manager/agent.py",
      "indexed_at": "2025-07-22T14:24:19.166114"
    },
    "displayName": "ADK Example: 7-multi-agent (code)"
  },
  {
    "id": "adk_code_982a23a5",
    "content": "# ADK Example: 7-multi-agent\n# File: 7-multi-agent/manager/tools/tools.py\n\nfrom datetime import datetime\n\n\ndef get_current_time() -> dict:\n    \"\"\"\n    Get the current time in the format YYYY-MM-DD HH:MM:SS\n    \"\"\"\n    return {\n        \"current_time\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n    }\n\n\n# This code demonstrates:\n# - ADK patterns for multi agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "7-multi-agent",
      "type": "code",
      "file": "7-multi-agent/manager/tools/tools.py",
      "indexed_at": "2025-07-22T14:24:19.166296"
    },
    "displayName": "ADK Example: 7-multi-agent (code)"
  },
  {
    "id": "adk_code_d9421ba6",
    "content": "# ADK Example: 7-multi-agent\n# File: 7-multi-agent/manager/sub_agents/stock_analyst/agent.py\n\nfrom datetime import datetime\n\nimport yfinance as yf\nfrom google.adk.agents import Agent\n\n\ndef get_stock_price(ticker: str) -> dict:\n    \"\"\"Retrieves current stock price and saves to session state.\"\"\"\n    print(f\"--- Tool: get_stock_price called for {ticker} ---\")\n\n    try:\n        # Fetch stock data\n        stock = yf.Ticker(ticker)\n        current_price = stock.info.get(\"currentPrice\")\n\n        if current_price is None:\n            return {\n                \"status\": \"error\",\n                \"error_message\": f\"Could not fetch price for {ticker}\",\n            }\n\n        # Get current timestamp\n        current_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n        return {\n            \"status\": \"success\",\n            \"ticker\": ticker,\n            \"price\": current_price,\n            \"timestamp\": current_time,\n        }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"error_message\": f\"Error fetching stock data: {str(e)}\",\n        }\n\n\n# Create the root agent\nstock_analyst = Agent(\n    name=\"stock_analyst\",\n    model=\"gemini-2.0-flash\",\n    description=\"An agent that can look up stock prices and track them over time.\",\n    instruction=\"\"\"\n    You are a helpful stock market assistant that helps users track their stocks of interest.\n    \n    When asked about stock prices:\n    1. Use the get_stock_price tool to fetch the latest price for the requested stock(s)\n    2. Format the response to show each stock's current price and the time it was fetched\n    3. If a stock price couldn't be fetched, mention this in your response\n    \n    Example response format:\n    \"Here are the current prices for your stocks:\n    - GOOG: $175.34 (updated at 2024-04-21 16:30:00)\n    - TSLA: $156.78 (updated at 2024-04-21 16:30:00)\n    - META: $123.45 (updated at 2024-04-21 16:30:00)\"\n    \"\"\",\n    tools=[get_stock_price],\n)\n\n\n# This code demonstrates:\n# - ADK patterns for multi agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "7-multi-agent",
      "type": "code",
      "file": "7-multi-agent/manager/sub_agents/stock_analyst/agent.py",
      "indexed_at": "2025-07-22T14:24:19.166495"
    },
    "displayName": "ADK Example: 7-multi-agent (code)"
  },
  {
    "id": "adk_code_b40864de",
    "content": "# ADK Example: 7-multi-agent\n# File: 7-multi-agent/manager/sub_agents/funny_nerd/agent.py\n\nfrom google.adk.agents import Agent\nfrom google.adk.tools.tool_context import ToolContext\n\n\ndef get_nerd_joke(topic: str, tool_context: ToolContext) -> dict:\n    \"\"\"Get a nerdy joke about a specific topic.\"\"\"\n    print(f\"--- Tool: get_nerd_joke called for topic: {topic} ---\")\n\n    # Example jokes - in a real implementation, you might want to use an API\n    jokes = {\n        \"python\": \"Why don't Python programmers like to use inheritance? Because they don't like to inherit anything!\",\n        \"javascript\": \"Why did the JavaScript developer go broke? Because he used up all his cache!\",\n        \"java\": \"Why do Java developers wear glasses? Because they can't C#!\",\n        \"programming\": \"Why do programmers prefer dark mode? Because light attracts bugs!\",\n        \"math\": \"Why was the equal sign so humble? Because he knew he wasn't less than or greater than anyone else!\",\n        \"physics\": \"Why did the photon check a hotel? Because it was travelling light!\",\n        \"chemistry\": \"Why did the acid go to the gym? To become a buffer solution!\",\n        \"biology\": \"Why did the cell go to therapy? Because it had too many issues!\",\n        \"default\": \"Why did the computer go to the doctor? Because it had a virus!\",\n    }\n\n    joke = jokes.get(topic.lower(), jokes[\"default\"])\n\n    # Update state with the last joke topic\n    tool_context.state[\"last_joke_topic\"] = topic\n\n    return {\"status\": \"success\", \"joke\": joke, \"topic\": topic}\n\n\n# Create the funny nerd agent\nfunny_nerd = Agent(\n    name=\"funny_nerd\",\n    model=\"gemini-2.0-flash\",\n    description=\"An agent that tells nerdy jokes about various topics.\",\n    instruction=\"\"\"\n    You are a funny nerd agent that tells nerdy jokes about various topics.\n    \n    When asked to tell a joke:\n    1. Use the get_nerd_joke tool to fetch a joke about the requested topic\n    2. If no specific topic is mentioned, ask the user what kind of nerdy joke they'd like to hear\n    3. Format the response to include both the joke and a brief explanation if needed\n    \n    Available topics include:\n    - python\n    - javascript\n    - java\n    - programming\n    - math\n    - physics\n    - chemistry\n    - biology\n    \n    Example response format:\n    \"Here's a nerdy joke about <TOPIC>:\n    <JOKE>\n    \n    Explanation: {brief explanation if needed}\"\n\n    If the user asks about anything else, \n    you should delegate the task to the manager agent.\n    \"\"\",\n    tools=[get_nerd_joke],\n)\n\n\n# This code demonstrates:\n# - ADK patterns for multi agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "7-multi-agent",
      "type": "code",
      "file": "7-multi-agent/manager/sub_agents/funny_nerd/agent.py",
      "indexed_at": "2025-07-22T14:24:19.166569"
    },
    "displayName": "ADK Example: 7-multi-agent (code)"
  },
  {
    "id": "adk_code_232802d5",
    "content": "# ADK Example: 7-multi-agent\n# File: 7-multi-agent/manager/sub_agents/news_analyst/agent.py\n\nfrom google.adk.agents import Agent\nfrom google.adk.tools import google_search\n\nnews_analyst = Agent(\n    name=\"news_analyst\",\n    model=\"gemini-2.0-flash\",\n    description=\"News analyst agent\",\n    instruction=\"\"\"\n    You are a helpful assistant that can analyze news articles and provide a summary of the news.\n\n    When asked about news, you should use the google_search tool to search for the news.\n\n    If the user ask for news using a relative time, you should use the get_current_time tool to get the current time to use in the search query.\n    \"\"\",\n    tools=[google_search],\n)\n\n\n# This code demonstrates:\n# - ADK patterns for multi agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "7-multi-agent",
      "type": "code",
      "file": "7-multi-agent/manager/sub_agents/news_analyst/agent.py",
      "indexed_at": "2025-07-22T14:24:19.166685"
    },
    "displayName": "ADK Example: 7-multi-agent (code)"
  },
  {
    "id": "adk_example_8-stateful-multi-agent",
    "content": "# Stateful Multi-Agent Systems in ADK\n\nThis example demonstrates how to create a stateful multi-agent system in ADK, combining the power of persistent state management with specialized agent delegation. This approach creates intelligent agent systems that remember user information across interactions while leveraging specialized domain expertise.\n\n## What is a Stateful Multi-Agent System?\n\nA Stateful Multi-Agent System combines two powerful patterns:\n\n1. **State Management**: Persisting information about users and conversations across interactions\n2. **Multi-Agent Architecture**: Distributing tasks among specialized agents based on their expertise\n\nThe result is a sophisticated agent ecosystem that can:\n- Remember user information and interaction history\n- Route queries to the most appropriate specialized agent\n- Provide personalized responses based on past interactions\n- Maintain context across multiple agent delegates\n\nThis example implements a customer service system for an online course platform, where specialized agents handle different aspects of customer support while sharing a common state.\n\n## Project Structure\n\n```\n7-stateful-multi-agent/\n│\n├── customer_service_agent/         # Main agent package\n│   ├── __init__.py                 # Required for ADK discovery\n│   ├── agent.py                    # Root agent definition\n│   └── sub_agents/                 # Specialized agents\n│       ├── course_support_agent/   # Handles course content questions\n│       ├── order_agent/            # Manages order history and refunds\n│       ├── policy_agent/           # Answers policy questions\n│       └── sales_agent/            # Handles course purchases\n│\n├── main.py                         # Application entry point with session setup\n├── utils.py                        # Helper functions for state management\n├── .env                            # Environment variables\n└── README.md                       # This documentation\n```\n\n## Key Components\n\n### 1. Session Management\n\nThe example uses `InMemorySessionService` to store session state:\n\n```python\nsession_service = InMemorySessionService()\n\ndef initialize_state():\n    \"\"\"Initialize the session state with default values.\"\"\"\n    return {\n        \"user_name\": \"Brandon Hancock\",\n        \"purchased_courses\": [\"\"],\n        \"interaction_history\": [],\n    }\n\n# Create a new session with initial state\nsession_service.create_session(\n    app_name=APP_NAME,\n    user_id=USER_ID,\n    session_id=SESSION_ID,\n    state=initialize_state(),\n)\n```\n\n### 2. State Sharing Across Agents\n\nAll agents in the system can access the same session state, enabling:\n- Root agent to track interaction history\n- Sales agent to update purchased courses\n- Course support agent to check if user has purchased specific courses\n- All agents to personalize responses based on user information\n\n### 3. Multi-Agent Delegation\n\nThe customer service agent routes queries to specialized sub-agents:\n\n```python\ncustomer_service_agent = Agent(\n    name=\"customer_service\",\n    model=\"gemini-2.0-flash\",\n    description=\"Customer service agent for AI Developer Accelerator community\",\n    instruction=\"\"\"\n    You are the primary customer service agent for the AI Developer Accelerator community.\n    Your role is to help users with their questions and direct them to the appropriate specialized agent.\n    \n    # ... detailed instructions ...\n    \n    \"\"\",\n    sub_agents=[policy_agent, sales_agent, course_support_agent, order_agent],\n    tools=[get_current_time],\n)\n```\n\n## How It Works\n\n1. **Initial Session Creation**:\n   - A new session is created with user information and empty interaction history\n   - Session state is initialized with default values\n\n2. **Conversation Tracking**:\n   - Each user message is added to `interaction_history` in the state\n   - Agents can review past interactions to maintain context\n\n3. **Query Routing**:\n   - The root agent analyzes the user query and decides which specialist should handle it\n   - Specialized agents receive the full state context when delegated to\n\n4. **State Updates**:\n   - When a user purchases a course, the sales agent updates `purchased_courses`\n   - These updates are available to all agents for future interactions\n\n5. **Personalized Responses**:\n   - Agents tailor responses based on purchase history and previous interactions\n   - Different paths are taken based on what the user has already purchased\n\n## Getting Started\n\n\n### Setup\n\n1. Activate the virtual environment from the root directory:\n```bash\n# macOS/Linux:\nsource ../.venv/bin/activate\n# Windows CMD:\n..\\.venv\\Scripts\\activate.bat\n# Windows PowerShell:\n..\\.venv\\Scripts\\Activate.ps1\n```\n\n2. Make sure your Google API key is set in the `.env` file:\n```\nGOOGLE_API_KEY=your_api_key_here\n```\n\n### Running the Example\n\nTo run the stateful multi-agent example:\n\n```bash\npython main.py\n```\n\nThis will:\n1. Initialize a new session with default state\n2. Start an interactive conversation with the customer service agent\n3. Track all interactions in the session state\n4. Allow specialized agents to handle specific queries\n\n### Example Conversation Flow\n\nTry this conversation flow to test the system:\n\n1. **Start with a general query**:\n   - \"What courses do you offer?\"\n   - (Root agent will route to sales agent)\n\n2. **Ask about purchasing**:\n   - \"I want to buy the AI Marketing Platform course\"\n   - (Sales agent will process the purchase and update state)\n\n3. **Ask about course content**:\n   - \"Can you tell me about the content in the AI Marketing Platform course?\"\n   - (Root agent will route to course support agent, which now has access)\n\n4. **Ask about refunds**:\n   - \"What's your refund policy?\"\n   - (Root agent will route to policy agent)\n\nNotice how the system remembers your purchase across different specialized agents!\n\n## Advanced Features\n\n### 1. Interaction History Tracking\n\nThe system maintains a history of interactions to provide context:\n\n```python\n# Update interaction history with the user's query\nadd_user_query_to_history(\n    session_service, APP_NAME, USER_ID, SESSION_ID, user_input\n)\n```\n\n### 2. Dynamic Access Control\n\nThe system implements conditional access to certain agents:\n\n```\n3. Course Support Agent\n   - For questions about course content\n   - Only available for courses the user has purchased\n   - Check if \"ai_marketing_platform\" is in the purchased courses before directing here\n```\n\n### 3. State-Based Personalization\n\nAll agents tailor responses based on session state:\n\n```\nTailor your responses based on the user's purchase history and previous interactions.\nWhen the user hasn't purchased any courses yet, encourage them to explore the AI Marketing Platform.\nWhen the user has purchased courses, offer support for those specific courses.\n```\n\n## Production Considerations\n\nFor a production implementation, consider:\n\n1. **Persistent Storage**: Replace `InMemorySessionService` with `DatabaseSessionService` to persist state across application restarts\n2. **User Authentication**: Implement proper user authentication to securely identify users\n3. **Error Handling**: Add robust error handling for agent failures and state corruption\n4. **Monitoring**: Implement logging and monitoring to track system performance\n\n## Additional Resources\n\n- [ADK Sessions Documentation](https://google.github.io/adk-docs/sessions/session/)\n- [ADK Multi-Agent Systems Documentation](https://google.github.io/adk-docs/agents/multi-agent-systems/)\n- [State Management in ADK](https://google.github.io/adk-docs/sessions/state/)\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "8-stateful-multi-agent",
      "type": "documentation",
      "file": "README.md",
      "indexed_at": "2025-07-22T14:24:19.167020"
    },
    "displayName": "ADK Example: 8-stateful-multi-agent (documentation)"
  },
  {
    "id": "adk_code_1ed40dbf",
    "content": "# ADK Example: 8-stateful-multi-agent\n# File: 8-stateful-multi-agent/utils.py\n\nfrom datetime import datetime\n\nfrom google.genai import types\n\n\n# ANSI color codes for terminal output\nclass Colors:\n    RESET = \"\\033[0m\"\n    BOLD = \"\\033[1m\"\n    UNDERLINE = \"\\033[4m\"\n\n    # Foreground colors\n    BLACK = \"\\033[30m\"\n    RED = \"\\033[31m\"\n    GREEN = \"\\033[32m\"\n    YELLOW = \"\\033[33m\"\n    BLUE = \"\\033[34m\"\n    MAGENTA = \"\\033[35m\"\n    CYAN = \"\\033[36m\"\n    WHITE = \"\\033[37m\"\n\n    # Background colors\n    BG_BLACK = \"\\033[40m\"\n    BG_RED = \"\\033[41m\"\n    BG_GREEN = \"\\033[42m\"\n    BG_YELLOW = \"\\033[43m\"\n    BG_BLUE = \"\\033[44m\"\n    BG_MAGENTA = \"\\033[45m\"\n    BG_CYAN = \"\\033[46m\"\n    BG_WHITE = \"\\033[47m\"\n\n\ndef update_interaction_history(session_service, app_name, user_id, session_id, entry):\n    \"\"\"Add an entry to the interaction history in state.\n\n    Args:\n        session_service: The session service instance\n        app_name: The application name\n        user_id: The user ID\n        session_id: The session ID\n        entry: A dictionary containing the interaction data\n            - requires 'action' key (e.g., 'user_query', 'agent_response')\n            - other keys are flexible depending on the action type\n    \"\"\"\n    try:\n        # Get current session\n        session = session_service.get_session(\n            app_name=app_name, user_id=user_id, session_id=session_id\n        )\n\n        # Get current interaction history\n        interaction_history = session.state.get(\"interaction_history\", [])\n\n        # Add timestamp if not already present\n        if \"timestamp\" not in entry:\n            entry[\"timestamp\"] = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n        # Add the entry to interaction history\n        interaction_history.append(entry)\n\n        # Create updated state\n        updated_state = session.state.copy()\n        updated_state[\"interaction_history\"] = interaction_history\n\n        # Create a new session with updated state\n        session_service.create_session(\n            app_name=app_name,\n            user_id=user_id,\n            session_id=session_id,\n            state=updated_state,\n        )\n    except Exception as e:\n        print(f\"Error updating interaction history: {e}\")\n\n\ndef add_user_query_to_history(session_service, app_name, user_id, session_id, query):\n    \"\"\"Add a user query to the interaction history.\"\"\"\n    update_interaction_history(\n        session_service,\n        app_name,\n        user_id,\n        session_id,\n        {\n            \"action\": \"user_query\",\n            \"query\": query,\n        },\n    )\n\n\ndef add_agent_response_to_history(\n    session_service, app_name, user_id, session_id, agent_name, response\n):\n    \"\"\"Add an agent response to the interaction history.\"\"\"\n    update_interaction_history(\n        session_service,\n        app_name,\n        user_id,\n        session_id,\n        {\n            \"action\": \"agent_response\",\n            \"agent\": agent_name,\n            \"response\": response,\n        },\n    )\n\n\ndef display_state(\n    session_service, app_name, user_id, session_id, label=\"Current State\"\n):\n    \"\"\"Display the current session state in a formatted way.\"\"\"\n    try:\n        session = session_service.get_session(\n            app_name=app_name, user_id=user_id, session_id=session_id\n        )\n\n        # Format the output with clear sections\n        print(f\"\\n{'-' * 10} {label} {'-' * 10}\")\n\n        # Handle the user name\n        user_name = session.state.get(\"user_name\", \"Unknown\")\n        print(f\"👤 User: {user_name}\")\n\n        # Handle purchased courses\n        purchased_courses = session.state.get(\"purchased_courses\", [])\n        if purchased_courses and any(purchased_courses):\n            print(\"📚 Courses:\")\n            for course in purchased_courses:\n                if isinstance(course, dict):\n                    course_id = course.get(\"id\", \"Unknown\")\n                    purchase_date = course.get(\"purchase_date\", \"Unknown date\")\n                    print(f\"  - {course_id} (purchased on {purchase_date})\")\n                elif course:  # Handle string format for backward compatibility\n                    print(f\"  - {course}\")\n        else:\n            print(\"📚 Courses: None\")\n\n        # Handle interaction history in a more readable way\n        interaction_history = session.state.get(\"interaction_history\", [])\n        if interaction_history:\n            print(\"📝 Interaction History:\")\n            for idx, interaction in enumerate(interaction_history, 1):\n                # Pretty format dict entries, or just show strings\n                if isinstance(interaction, dict):\n                    action = interaction.get(\"action\", \"interaction\")\n                    timestamp = interaction.get(\"timestamp\", \"unknown time\")\n\n                    if action == \"user_query\":\n                        query = interaction.get(\"query\", \"\")\n                        print(f'  {idx}. User query at {timestamp}: \"{query}\"')\n                    elif action == \"agent_response\":\n                        agent = interaction.get(\"agent\", \"unknown\")\n                        response = interaction.get(\"response\", \"\")\n                        # Truncate very long responses for display\n                        if len(response) > 100:\n                            response = response[:97] + \"...\"\n                        print(f'  {idx}. {agent} response at {timestamp}: \"{response}\"')\n                    else:\n                        details = \", \".join(\n                            f\"{k}: {v}\"\n                            for k, v in interaction.items()\n                            if k not in [\"action\", \"timestamp\"]\n                        )\n                        print(\n                            f\"  {idx}. {action} at {timestamp}\"\n                            + (f\" ({details})\" if details else \"\")\n                        )\n                else:\n                    print(f\"  {idx}. {interaction}\")\n        else:\n            print(\"📝 Interaction History: None\")\n\n        # Show any additional state keys that might exist\n        other_keys = [\n            k\n            for k in session.state.keys()\n            if k not in [\"user_name\", \"purchased_courses\", \"interaction_history\"]\n        ]\n        if other_keys:\n            print(\"🔑 Additional State:\")\n            for key in other_keys:\n                print(f\"  {key}: {session.state[key]}\")\n\n        print(\"-\" * (22 + len(label)))\n    except Exception as e:\n        print(f\"Error displaying state: {e}\")\n\n\nasync def process_agent_response(event):\n    \"\"\"Process and display agent response events.\"\"\"\n    print(f\"Event ID: {event.id}, Author: {event.author}\")\n\n    # Check for specific parts first\n    has_specific_part = False\n    if event.content and event.content.parts:\n        for part in event.content.parts:\n            if hasattr(part, \"text\") and part.text and not part.text.isspace():\n                print(f\"  Text: '{part.text.strip()}'\")\n\n    # Check for final response after specific parts\n    final_response = None\n    if not has_specific_part and event.is_final_response():\n        if (\n            event.content\n            and event.content.parts\n            and hasattr(event.content.parts[0], \"text\")\n            and event.content.parts[0].text\n        ):\n            final_response = event.content.parts[0].text.strip()\n            # Use colors and formatting to make the final response stand out\n            print(\n                f\"\\n{Colors.BG_BLUE}{Colors.WHITE}{Colors.BOLD}╔══ AGENT RESPONSE ═════════════════════════════════════════{Colors.RESET}\"\n            )\n            print(f\"{Colors.CYAN}{Colors.BOLD}{final_response}{Colors.RESET}\")\n            print(\n                f\"{Colors.BG_BLUE}{Colors.WHITE}{Colors.BOLD}╚═════════════════════════════════════════════════════════════{Colors.RESET}\\n\"\n            )\n        else:\n            print(\n                f\"\\n{Colors.BG_RED}{Colors.WHITE}{Colors.BOLD}==> Final Agent Response: [No text content in final event]{Colors.RESET}\\n\"\n            )\n\n    return final_response\n\n\nasync def call_agent_async(runner, user_id, session_id, query):\n    \"\"\"Call the agent asynchronously with the user's query.\"\"\"\n    content = types.Content(role=\"user\", parts=[types.Part(text=query)])\n    print(\n        f\"\\n{Colors.BG_GREEN}{Colors.BLACK}{Colors.BOLD}--- Running Query: {query} ---{Colors.RESET}\"\n    )\n    final_response_text = None\n    agent_name = None\n\n    # Display state before processing the message\n    display_state(\n        runner.session_service,\n        runner.app_name,\n        user_id,\n        session_id,\n        \"State BEFORE processing\",\n    )\n\n    try:\n        async for event in runner.run_async(\n            user_id=user_id, session_id=session_id, new_message=content\n        ):\n            # Capture the agent name from the event if available\n            if event.author:\n                agent_name = event.author\n\n            response = await process_agent_response(event)\n            if response:\n                final_response_text = response\n    except Exception as e:\n        print(f\"{Colors.BG_RED}{Colors.WHITE}ERROR during agent run: {e}{Colors.RESET}\")\n\n    # Add the agent response to interaction history if we got a final response\n    if final_response_text and agent_name:\n        add_agent_response_to_history(\n            runner.session_service,\n            runner.app_name,\n            user_id,\n            session_id,\n            agent_name,\n            final_response_text,\n        )\n\n    # Display state after processing the message\n    display_state(\n        runner.session_service,\n        runner.app_name,\n        user_id,\n        session_id,\n        \"State AFTER processing\",\n    )\n\n    print(f\"{Colors.YELLOW}{'-' * 30}{Colors.RESET}\")\n    return final_response_text\n\n\n# This code demonstrates:\n# - ADK patterns for stateful multi agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "8-stateful-multi-agent",
      "type": "code",
      "file": "8-stateful-multi-agent/utils.py",
      "indexed_at": "2025-07-22T14:24:19.167248"
    },
    "displayName": "ADK Example: 8-stateful-multi-agent (code)"
  },
  {
    "id": "adk_code_8a54bd87",
    "content": "# ADK Example: 8-stateful-multi-agent\n# File: 8-stateful-multi-agent/main.py\n\nimport asyncio\n\n# Import the main customer service agent\nfrom customer_service_agent.agent import customer_service_agent\nfrom dotenv import load_dotenv\nfrom google.adk.runners import Runner\nfrom google.adk.sessions import InMemorySessionService\nfrom utils import add_user_query_to_history, call_agent_async\n\nload_dotenv()\n\n# ===== PART 1: Initialize In-Memory Session Service =====\n# Using in-memory storage for this example (non-persistent)\nsession_service = InMemorySessionService()\n\n\n# ===== PART 2: Define Initial State =====\n# This will be used when creating a new session\ninitial_state = {\n    \"user_name\": \"Brandon Hancock\",\n    \"purchased_courses\": [],\n    \"interaction_history\": [],\n}\n\n\nasync def main_async():\n    # Setup constants\n    APP_NAME = \"Customer Support\"\n    USER_ID = \"aiwithbrandon\"\n\n    # ===== PART 3: Session Creation =====\n    # Create a new session with initial state\n    new_session = session_service.create_session(\n        app_name=APP_NAME,\n        user_id=USER_ID,\n        state=initial_state,\n    )\n    SESSION_ID = new_session.id\n    print(f\"Created new session: {SESSION_ID}\")\n\n    # ===== PART 4: Agent Runner Setup =====\n    # Create a runner with the main customer service agent\n    runner = Runner(\n        agent=customer_service_agent,\n        app_name=APP_NAME,\n        session_service=session_service,\n    )\n\n    # ===== PART 5: Interactive Conversation Loop =====\n    print(\"\\nWelcome to Customer Service Chat!\")\n    print(\"Type 'exit' or 'quit' to end the conversation.\\n\")\n\n    while True:\n        # Get user input\n        user_input = input(\"You: \")\n\n        # Check if user wants to exit\n        if user_input.lower() in [\"exit\", \"quit\"]:\n            print(\"Ending conversation. Goodbye!\")\n            break\n\n        # Update interaction history with the user's query\n        add_user_query_to_history(\n            session_service, APP_NAME, USER_ID, SESSION_ID, user_input\n        )\n\n        # Process the user query through the agent\n        await call_agent_async(runner, USER_ID, SESSION_ID, user_input)\n\n    # ===== PART 6: State Examination =====\n    # Show final session state\n    final_session = session_service.get_session(\n        app_name=APP_NAME, user_id=USER_ID, session_id=SESSION_ID\n    )\n    print(\"\\nFinal Session State:\")\n    for key, value in final_session.state.items():\n        print(f\"{key}: {value}\")\n\n\ndef main():\n    \"\"\"Entry point for the application.\"\"\"\n    asyncio.run(main_async())\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n# This code demonstrates:\n# - ADK patterns for stateful multi agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "8-stateful-multi-agent",
      "type": "code",
      "file": "8-stateful-multi-agent/main.py",
      "indexed_at": "2025-07-22T14:24:19.167398"
    },
    "displayName": "ADK Example: 8-stateful-multi-agent (code)"
  },
  {
    "id": "adk_code_4d3d1bfe",
    "content": "# ADK Example: 8-stateful-multi-agent\n# File: 8-stateful-multi-agent/customer_service_agent/agent.py\n\nfrom google.adk.agents import Agent\n\nfrom .sub_agents.course_support_agent.agent import course_support_agent\nfrom .sub_agents.order_agent.agent import order_agent\nfrom .sub_agents.policy_agent.agent import policy_agent\nfrom .sub_agents.sales_agent.agent import sales_agent\n\n# Create the root customer service agent\ncustomer_service_agent = Agent(\n    name=\"customer_service\",\n    model=\"gemini-2.0-flash\",\n    description=\"Customer service agent for AI Developer Accelerator community\",\n    instruction=\"\"\"\n    You are the primary customer service agent for the AI Developer Accelerator community.\n    Your role is to help users with their questions and direct them to the appropriate specialized agent.\n\n    **Core Capabilities:**\n\n    1. Query Understanding & Routing\n       - Understand user queries about policies, course purchases, course support, and orders\n       - Direct users to the appropriate specialized agent\n       - Maintain conversation context using state\n\n    2. State Management\n       - Track user interactions in state['interaction_history']\n       - Monitor user's purchased courses in state['purchased_courses']\n         - Course information is stored as objects with \"id\" and \"purchase_date\" properties\n       - Use state to provide personalized responses\n\n    **User Information:**\n    <user_info>\n    Name: {user_name}\n    </user_info>\n\n    **Purchase Information:**\n    <purchase_info>\n    Purchased Courses: {purchased_courses}\n    </purchase_info>\n\n    **Interaction History:**\n    <interaction_history>\n    {interaction_history}\n    </interaction_history>\n\n    You have access to the following specialized agents:\n\n    1. Policy Agent\n       - For questions about community guidelines, course policies, refunds\n       - Direct policy-related queries here\n\n    2. Sales Agent\n       - For questions about purchasing the AI Marketing Platform course\n       - Handles course purchases and updates state\n       - Course price: $149\n\n    3. Course Support Agent\n       - For questions about course content\n       - Only available for courses the user has purchased\n       - Check if a course with id \"ai_marketing_platform\" exists in the purchased courses before directing here\n\n    4. Order Agent\n       - For checking purchase history and processing refunds\n       - Shows courses user has bought\n       - Can process course refunds (30-day money-back guarantee)\n       - References the purchased courses information\n\n    Tailor your responses based on the user's purchase history and previous interactions.\n    When the user hasn't purchased any courses yet, encourage them to explore the AI Marketing Platform.\n    When the user has purchased courses, offer support for those specific courses.\n\n    When users express dissatisfaction or ask for a refund:\n    - Direct them to the Order Agent, which can process refunds\n    - Mention our 30-day money-back guarantee policy\n\n    Always maintain a helpful and professional tone. If you're unsure which agent to delegate to,\n    ask clarifying questions to better understand the user's needs.\n    \"\"\",\n    sub_agents=[policy_agent, sales_agent, course_support_agent, order_agent],\n    tools=[],\n)\n\n\n# This code demonstrates:\n# - ADK patterns for stateful multi agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "8-stateful-multi-agent",
      "type": "code",
      "file": "8-stateful-multi-agent/customer_service_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.167581"
    },
    "displayName": "ADK Example: 8-stateful-multi-agent (code)"
  },
  {
    "id": "adk_code_16dabbb8",
    "content": "# ADK Example: 8-stateful-multi-agent\n# File: 8-stateful-multi-agent/customer_service_agent/sub_agents/order_agent/agent.py\n\nfrom datetime import datetime\n\nfrom google.adk.agents import Agent\nfrom google.adk.tools.tool_context import ToolContext\n\n\ndef get_current_time() -> dict:\n    \"\"\"Get the current time in the format YYYY-MM-DD HH:MM:SS\"\"\"\n    return {\n        \"current_time\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n    }\n\n\ndef refund_course(tool_context: ToolContext) -> dict:\n    \"\"\"\n    Simulates refunding the AI Marketing Platform course.\n    Updates state by removing the course from purchased_courses.\n    \"\"\"\n    course_id = \"ai_marketing_platform\"\n    current_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    # Get current purchased courses\n    current_purchased_courses = tool_context.state.get(\"purchased_courses\", [])\n\n    # Check if user owns the course\n    course_ids = [\n        course[\"id\"] for course in current_purchased_courses if isinstance(course, dict)\n    ]\n    if course_id not in course_ids:\n        return {\n            \"status\": \"error\",\n            \"message\": \"You don't own this course, so it can't be refunded.\",\n        }\n\n    # Create new list without the course to be refunded\n    new_purchased_courses = []\n    for course in current_purchased_courses:\n        # Skip empty entries or non-dict entries\n        if not course or not isinstance(course, dict):\n            continue\n        # Skip the course being refunded\n        if course.get(\"id\") == course_id:\n            continue\n        # Keep all other courses\n        new_purchased_courses.append(course)\n\n    # Update purchased courses in state via assignment\n    tool_context.state[\"purchased_courses\"] = new_purchased_courses\n\n    # Get current interaction history\n    current_interaction_history = tool_context.state.get(\"interaction_history\", [])\n\n    # Create new interaction history with refund added\n    new_interaction_history = current_interaction_history.copy()\n    new_interaction_history.append(\n        {\"action\": \"refund_course\", \"course_id\": course_id, \"timestamp\": current_time}\n    )\n\n    # Update interaction history in state via assignment\n    tool_context.state[\"interaction_history\"] = new_interaction_history\n\n    return {\n        \"status\": \"success\",\n        \"message\": \"\"\"Successfully refunded the AI Marketing Platform course! \n         Your $149 will be returned to your original payment method within 3-5 business days.\"\"\",\n        \"course_id\": course_id,\n        \"timestamp\": current_time,\n    }\n\n\n# Create the order agent\norder_agent = Agent(\n    name=\"order_agent\",\n    model=\"gemini-2.0-flash\",\n    description=\"Order agent for viewing purchase history and processing refunds\",\n    instruction=\"\"\"\n    You are the order agent for the AI Developer Accelerator community.\n    Your role is to help users view their purchase history, course access, and process refunds.\n\n    <user_info>\n    Name: {user_name}\n    </user_info>\n\n    <purchase_info>\n    Purchased Courses: {purchased_courses}\n    </purchase_info>\n\n    <interaction_history>\n    {interaction_history}\n    </interaction_history>\n\n    When users ask about their purchases:\n    1. Check their course list from the purchase info above\n       - Course information is stored as objects with \"id\" and \"purchase_date\" properties\n    2. Format the response clearly showing:\n       - Which courses they own\n       - When they were purchased (from the course.purchase_date property)\n\n    When users request a refund:\n    1. Verify they own the course they want to refund (\"ai_marketing_platform\")\n    2. If they own it:\n       - Use the refund_course tool to process the refund\n       - Confirm the refund was successful\n       - Remind them the money will be returned to their original payment method\n       - If it's been more than 30 days, inform them that they are not eligible for a refund\n    3. If they don't own it:\n       - Inform them they don't own the course, so no refund is needed\n\n    Course Information:\n    - ai_marketing_platform: \"Fullstack AI Marketing Platform\" ($149)\n\n    Example Response for Purchase History:\n    \"Here are your purchased courses:\n    1. Fullstack AI Marketing Platform\n       - Purchased on: 2024-04-21 10:30:00\n       - Full lifetime access\"\n\n    Example Response for Refund:\n    \"I've processed your refund for the Fullstack AI Marketing Platform course.\n    Your $149 will be returned to your original payment method within 3-5 business days.\n    The course has been removed from your account.\"\n\n    If they haven't purchased any courses:\n    - Let them know they don't have any courses yet\n    - Suggest talking to the sales agent about the AI Marketing Platform course\n\n    Remember:\n    - Be clear and professional\n    - Mention our 30-day money-back guarantee if relevant\n    - Direct course questions to course support\n    - Direct purchase inquiries to sales\n    \"\"\",\n    tools=[refund_course, get_current_time],\n)\n\n\n# This code demonstrates:\n# - ADK patterns for stateful multi agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "8-stateful-multi-agent",
      "type": "code",
      "file": "8-stateful-multi-agent/customer_service_agent/sub_agents/order_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.167691"
    },
    "displayName": "ADK Example: 8-stateful-multi-agent (code)"
  },
  {
    "id": "adk_code_b55d5150",
    "content": "# ADK Example: 8-stateful-multi-agent\n# File: 8-stateful-multi-agent/customer_service_agent/sub_agents/policy_agent/agent.py\n\nfrom google.adk.agents import Agent\n\n# Create the policy agent\npolicy_agent = Agent(\n    name=\"policy_agent\",\n    model=\"gemini-2.0-flash\",\n    description=\"Policy agent for the AI Developer Accelerator community\",\n    instruction=\"\"\"\n    You are the policy agent for the AI Developer Accelerator community. Your role is to help users\n    understand our community guidelines and policies.\n\n    <user_info>\n    Name: {user_name}\n    </user_info>\n\n    Community Guidelines:\n    1. Promotions\n       - No self-promotion or advertising\n       - Focus on learning and growing together\n       - Share your work only in designated channels\n\n    2. Content Quality\n       - Provide detailed, helpful responses\n       - Include code examples when relevant\n       - Use proper formatting for code snippets\n\n    3. Behavior\n       - Be respectful and professional\n       - No politics or religion discussions\n       - Help maintain a positive learning environment\n\n    Course Policies:\n    1. Refund Policy\n       - 30-day money-back guarantee\n       - Full refund if you complete the course and aren't satisfied\n       - No questions asked\n\n    2. Course Access\n       - Lifetime access to course content\n       - 6 weeks of group support included\n       - Weekly coaching calls every Sunday\n\n    3. Code Usage\n       - You can use course code in your projects\n       - Credit not required but appreciated\n       - No reselling of course materials\n\n    Privacy Policy:\n    - We respect your privacy\n    - Your data is never sold\n    - Course progress is tracked for support purposes\n\n    When responding:\n    1. Be clear and direct\n    2. Quote relevant policy sections\n    3. Explain the reasoning behind policies\n    4. Direct complex issues to support\n    \"\"\",\n    tools=[],\n)\n\n\n# This code demonstrates:\n# - ADK patterns for stateful multi agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "8-stateful-multi-agent",
      "type": "code",
      "file": "8-stateful-multi-agent/customer_service_agent/sub_agents/policy_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.167937"
    },
    "displayName": "ADK Example: 8-stateful-multi-agent (code)"
  },
  {
    "id": "adk_code_6a91d4eb",
    "content": "# ADK Example: 8-stateful-multi-agent\n# File: 8-stateful-multi-agent/customer_service_agent/sub_agents/course_support_agent/agent.py\n\nfrom google.adk.agents import Agent\n\n# Create the course support agent\ncourse_support_agent = Agent(\n    name=\"course_support\",\n    model=\"gemini-2.0-flash\",\n    description=\"Course support agent for the AI Marketing Platform course\",\n    instruction=\"\"\"\n    You are the course support agent for the Fullstack AI Marketing Platform course.\n    Your role is to help users with questions about course content and sections.\n\n    <user_info>\n    Name: {user_name}\n    </user_info>\n\n    <purchase_info>\n    Purchased Courses: {purchased_courses}\n    </purchase_info>\n\n    Before helping:\n    - Check if the user owns the AI Marketing Platform course\n    - Course information is stored as objects with \"id\" and \"purchase_date\" properties\n    - Look for a course with id \"ai_marketing_platform\" in the purchased courses\n    - Only provide detailed help if they own the course\n    - If they don't own the course, direct them to the sales agent\n    - If they do own the course, you can mention when they purchased it (from the purchase_date property)\n\n    Course Sections:\n    1. Introduction\n       - Course Overview\n       - Tech Stack Introduction\n       - Project Goals\n\n    2. Problem, Solution, & Technical Design\n       - Market Analysis\n       - Architecture Overview\n       - Tech Stack Selection\n\n    3. Models & Views - How To Think\n       - Data Modeling\n       - View Structure\n       - Component Design\n\n    4. Setup Environment\n       - Development Tools\n       - Configuration\n       - Dependencies\n\n    5. Create Projects\n       - Project Structure\n       - Initial Setup\n       - Basic Configuration\n\n    6. Software Deployment Tools\n       - Deployment Options\n       - CI/CD Setup\n       - Monitoring\n\n    7. NextJS Crash Course\n       - Fundamentals\n       - Routing\n       - API Routes\n\n    8. Stub Out NextJS App\n       - Create app directory structure\n       - Setup initial layouts\n       - Configure NextJS routing\n       - Create placeholder components\n\n    9. Create Responsive Sidebar\n       - Design mobile-friendly sidebar\n       - Implement sidebar navigation\n       - Add responsive breakpoints\n       - Create menu toggling behavior\n\n    10. Setup Auth with Clerk\n       - Integrate Clerk authentication\n       - Create login/signup flows\n       - Configure protected routes\n       - Setup user session management\n\n    11. Setup Postgres Database & Blob Storage\n       - Configure database connections\n       - Create schema and migrations\n       - Setup file/image storage\n       - Implement data access patterns\n\n    12. Projects Build Out (List & Detail)\n       - Create projects listing page\n       - Implement project detail views\n       - Add CRUD operations for projects\n       - Create data fetching hooks\n\n    13. Asset Processing NextJS\n       - Client-side image optimization\n       - Asset loading strategies\n       - Implementing CDN integration\n       - Frontend caching mechanisms\n\n    14. Asset Processing Server\n       - Server-side image manipulation\n       - Batch processing workflows\n       - Compression and optimization\n       - Storage management solutions\n\n    15. Prompt Management\n       - Create prompt templates\n       - Build prompt versioning system\n       - Implement prompt testing tools\n       - Design prompt chaining capabilities\n\n    16. Fully Build Template (List & Detail)\n       - Create template management system\n       - Implement template editor\n       - Design template marketplace\n       - Add template sharing features\n\n    17. AI Content Generation\n       - Integrate AI generation capabilities\n       - Design content generation workflows\n       - Create output validation systems\n       - Implement feedback mechanisms\n\n    18. Setup Stripe + Block Free Users\n       - Integrate Stripe payment processing\n       - Create subscription management\n       - Implement payment webhooks\n       - Design feature access restrictions\n\n    19. Landing & Pricing Pages\n       - Design conversion-optimized landing pages\n       - Create pricing tier comparisons\n       - Implement checkout flows\n       - Add testimonials and social proof\n\n    When helping:\n    1. Direct users to specific sections\n    2. Explain concepts clearly\n    3. Provide context for how sections connect\n    4. Encourage hands-on practice\n    \"\"\",\n    tools=[],\n)\n\n\n# This code demonstrates:\n# - ADK patterns for stateful multi agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "8-stateful-multi-agent",
      "type": "code",
      "file": "8-stateful-multi-agent/customer_service_agent/sub_agents/course_support_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.168010"
    },
    "displayName": "ADK Example: 8-stateful-multi-agent (code)"
  },
  {
    "id": "adk_code_311394fe",
    "content": "# ADK Example: 8-stateful-multi-agent\n# File: 8-stateful-multi-agent/customer_service_agent/sub_agents/sales_agent/agent.py\n\nfrom datetime import datetime\n\nfrom google.adk.agents import Agent\nfrom google.adk.tools.tool_context import ToolContext\n\n\ndef purchase_course(tool_context: ToolContext) -> dict:\n    \"\"\"\n    Simulates purchasing the AI Marketing Platform course.\n    Updates state with purchase information.\n    \"\"\"\n    course_id = \"ai_marketing_platform\"\n    current_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    # Get current purchased courses\n    current_purchased_courses = tool_context.state.get(\"purchased_courses\", [])\n\n    # Check if user already owns the course\n    course_ids = [\n        course[\"id\"] for course in current_purchased_courses if isinstance(course, dict)\n    ]\n    if course_id in course_ids:\n        return {\"status\": \"error\", \"message\": \"You already own this course!\"}\n\n    # Create new list with the course added\n    new_purchased_courses = []\n    # Only include valid dictionary courses\n    for course in current_purchased_courses:\n        if isinstance(course, dict) and \"id\" in course:\n            new_purchased_courses.append(course)\n\n    # Add the new course as a dictionary with id and purchase_date\n    new_purchased_courses.append({\"id\": course_id, \"purchase_date\": current_time})\n\n    # Update purchased courses in state via assignment\n    tool_context.state[\"purchased_courses\"] = new_purchased_courses\n\n    # Get current interaction history\n    current_interaction_history = tool_context.state.get(\"interaction_history\", [])\n\n    # Create new interaction history with purchase added\n    new_interaction_history = current_interaction_history.copy()\n    new_interaction_history.append(\n        {\"action\": \"purchase_course\", \"course_id\": course_id, \"timestamp\": current_time}\n    )\n\n    # Update interaction history in state via assignment\n    tool_context.state[\"interaction_history\"] = new_interaction_history\n\n    return {\n        \"status\": \"success\",\n        \"message\": \"Successfully purchased the AI Marketing Platform course!\",\n        \"course_id\": course_id,\n        \"timestamp\": current_time,\n    }\n\n\n# Create the sales agent\nsales_agent = Agent(\n    name=\"sales_agent\",\n    model=\"gemini-2.0-flash\",\n    description=\"Sales agent for the AI Marketing Platform course\",\n    instruction=\"\"\"\n    You are a sales agent for the AI Developer Accelerator community, specifically handling sales\n    for the Fullstack AI Marketing Platform course.\n\n    <user_info>\n    Name: {user_name}\n    </user_info>\n\n    <purchase_info>\n    Purchased Courses: {purchased_courses}\n    </purchase_info>\n\n    <interaction_history>\n    {interaction_history}\n    </interaction_history>\n\n    Course Details:\n    - Name: Fullstack AI Marketing Platform\n    - Price: $149\n    - Value Proposition: Learn to build AI-powered marketing automation apps\n    - Includes: 6 weeks of group support with weekly coaching calls\n\n    When interacting with users:\n    1. Check if they already own the course (check purchased_courses above)\n       - Course information is stored as objects with \"id\" and \"purchase_date\" properties\n       - The course id is \"ai_marketing_platform\"\n    2. If they own it:\n       - Remind them they have access\n       - Ask if they need help with any specific part\n       - Direct them to course support for content questions\n    \n    3. If they don't own it:\n       - Explain the course value proposition\n       - Mention the price ($149)\n       - If they want to purchase:\n           - Use the purchase_course tool\n           - Confirm the purchase\n           - Ask if they'd like to start learning right away\n\n    4. After any interaction:\n       - The state will automatically track the interaction\n       - Be ready to hand off to course support after purchase\n\n    Remember:\n    - Be helpful but not pushy\n    - Focus on the value and practical skills they'll gain\n    - Emphasize the hands-on nature of building a real AI application\n    \"\"\",\n    tools=[purchase_course],\n)\n\n\n# This code demonstrates:\n# - ADK patterns for stateful multi agent\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "8-stateful-multi-agent",
      "type": "code",
      "file": "8-stateful-multi-agent/customer_service_agent/sub_agents/sales_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.168096"
    },
    "displayName": "ADK Example: 8-stateful-multi-agent (code)"
  },
  {
    "id": "adk_example_9-callbacks",
    "content": "# Callbacks in ADK\n\nThis example demonstrates how to use callbacks in the Agent Development Kit (ADK) to intercept and modify agent behavior at different stages of execution. Callbacks provide powerful hooks into the agent's lifecycle, allowing you to add custom logic for monitoring, logging, content filtering, and result transformation.\n\n## What are Callbacks in ADK?\n\nCallbacks are functions that execute at specific points in an agent's execution flow. They allow you to:\n\n1. **Monitor and Log**: Track agent activity and performance metrics\n2. **Filter Content**: Block inappropriate requests or responses\n3. **Transform Data**: Modify inputs and outputs in the agent workflow\n4. **Implement Security Policies**: Enforce compliance and safety measures\n5. **Add Custom Logic**: Insert business-specific processing into the agent flow\n\nADK provides several types of callbacks that can be attached to different components of your agent system.\n\n## Callback Parameters and Context\n\nEach type of callback provides access to specific context objects that contain valuable information about the current execution state. Understanding these parameters is key to building effective callbacks.\n\n### CallbackContext\n\nThe `CallbackContext` object is provided to all callback types and contains:\n\n- **`agent_name`**: The name of the agent being executed\n- **`invocation_id`**: A unique identifier for the current agent invocation\n- **`state`**: Access to the session state, allowing you to read/write persistent data\n- **`app_name`**: The name of the application\n- **`user_id`**: The ID of the current user\n- **`session_id`**: The ID of the current session\n\nExample usage:\n```python\ndef my_callback(callback_context: CallbackContext, ...):\n    # Access the state to store or retrieve data\n    user_name = callback_context.state.get(\"user_name\", \"Unknown\")\n    \n    # Log the current agent and invocation\n    print(f\"Agent {callback_context.agent_name} executing (ID: {callback_context.invocation_id})\")\n```\n\n### ToolContext (for Tool Callbacks)\n\nThe `ToolContext` object is provided to tool callbacks and contains:\n\n- **`agent_name`**: The name of the agent that initiated the tool call\n- **`state`**: Access to the session state, allowing tools to read/modify shared data\n- **`properties`**: Additional properties specific to the tool execution\n\nExample usage:\n```python\ndef before_tool_callback(tool: BaseTool, args: Dict[str, Any], tool_context: ToolContext):\n    # Record tool usage in state\n    tools_used = tool_context.state.get(\"tools_used\", [])\n    tools_used.append(tool.name)\n    tool_context.state[\"tools_used\"] = tools_used\n```\n\n### LlmRequest (for Model Callbacks)\n\nThe `LlmRequest` object is provided to the before_model_callback and contains:\n\n- **`contents`**: List of Content objects representing the conversation history\n- **`generation_config`**: Configuration for the model generation\n- **`safety_settings`**: Safety settings for the model\n- **`tools`**: Tools provided to the model\n\nExample usage:\n```python\ndef before_model_callback(callback_context: CallbackContext, llm_request: LlmRequest):\n    # Get the last user message for analysis\n    last_message = None\n    for content in reversed(llm_request.contents):\n        if content.role == \"user\" and content.parts:\n            last_message = content.parts[0].text\n            break\n            \n    # Analyze the user's message\n    if last_message and contains_sensitive_info(last_message):\n        # Return a response that bypasses the model call\n        return LlmResponse(...)\n```\n\n### LlmResponse (for Model Callbacks)\n\nThe `LlmResponse` object is returned from the model and provided to the after_model_callback:\n\n- **`content`**: Content object containing the model's response\n- **`tool_calls`**: Any tool calls the model wants to make\n- **`usage_metadata`**: Metadata about the model usage (tokens, etc.)\n\nExample usage:\n```python\ndef after_model_callback(callback_context: CallbackContext, llm_response: LlmResponse):\n    # Access the model's text response\n    if llm_response.content and llm_response.content.parts:\n        response_text = llm_response.content.parts[0].text\n        \n        # Modify the response\n        modified_text = transform_text(response_text)\n        llm_response.content.parts[0].text = modified_text\n        \n        return llm_response\n```\n\n## Types of Callbacks Demonstrated\n\nThis project includes three examples of callback patterns:\n\n### 1. Agent Callbacks (`before_after_agent/`)\n- **Before Agent Callback**: Runs at the start of agent processing\n- **After Agent Callback**: Runs after the agent completes processing\n\n### 2. Model Callbacks (`before_after_model/`)\n- **Before Model Callback**: Intercepts requests before they reach the LLM\n- **After Model Callback**: Modifies responses after they come from the LLM\n\n### 3. Tool Callbacks (`before_after_tool/`)\n- **Before Tool Callback**: Modifies tool arguments or skips tool execution\n- **After Tool Callback**: Enhances tool responses with additional information\n\n## Project Structure\n\n```\n8-callbacks/\n│\n├── before_after_agent/           # Agent callback example\n│   ├── __init__.py               # Required for ADK discovery\n│   ├── agent.py                  # Agent with agent callbacks\n│   └── .env                      # Environment variables\n│\n├── before_after_model/           # Model callback example\n│   ├── __init__.py               # Required for ADK discovery\n│   ├── agent.py                  # Agent with model callbacks\n│   └── .env                      # Environment variables\n│\n├── before_after_tool/            # Tool callback example\n│   ├── __init__.py               # Required for ADK discovery\n│   ├── agent.py                  # Agent with tool callbacks\n│   └── .env                      # Environment variables\n│\n└── README.md                     # This documentation\n```\n\n## Example 1: Agent Callbacks\n\nThe agent callbacks example demonstrates:\n\n1. **Request Logging**: Recording when requests start and finish\n2. **Performance Monitoring**: Measuring request duration\n3. **State Management**: Using session state to track request counts\n\n### Key Implementation Details\n\n```python\ndef before_agent_callback(callback_context: CallbackContext) -> Optional[types.Content]:\n    # Get the session state\n    state = callback_context.state\n    \n    # Initialize request counter\n    if \"request_counter\" not in state:\n        state[\"request_counter\"] = 1\n    else:\n        state[\"request_counter\"] += 1\n        \n    # Store start time for duration calculation\n    state[\"request_start_time\"] = datetime.now()\n    \n    # Log the request\n    logger.info(\"=== AGENT EXECUTION STARTED ===\")\n    \n    return None  # Continue with normal agent processing\n\ndef after_agent_callback(callback_context: CallbackContext) -> Optional[types.Content]:\n    # Get the session state\n    state = callback_context.state\n    \n    # Calculate request duration\n    duration = None\n    if \"request_start_time\" in state:\n        duration = (datetime.now() - state[\"request_start_time\"]).total_seconds()\n        \n    # Log the completion\n    logger.info(\"=== AGENT EXECUTION COMPLETED ===\")\n    \n    return None  # Continue with normal agent processing\n```\n\n### Testing Agent Callbacks\n\nAny interaction will demonstrate the agent callbacks, which log requests and measure duration.\n\n## Example 2: Model Callbacks\n\nThe model callbacks example demonstrates:\n\n1. **Content Filtering**: Blocking inappropriate content before it reaches the model\n2. **Response Transformation**: Replacing negative words with more positive alternatives\n\n### Key Implementation Details\n\n```python\ndef before_model_callback(\n    callback_context: CallbackContext, llm_request: LlmRequest\n) -> Optional[LlmResponse]:\n    # Check for inappropriate content\n    if last_user_message and \"sucks\" in last_user_message.lower():\n        # Return a response to skip the model call\n        return LlmResponse(\n            content=types.Content(\n                role=\"model\",\n                parts=[\n                    types.Part(\n                        text=\"I cannot respond to messages containing inappropriate language...\"\n                    )\n                ],\n            )\n        )\n    # Return None to proceed with normal model request\n    return None\n\ndef after_model_callback(\n    callback_context: CallbackContext, llm_response: LlmResponse\n) -> Optional[LlmResponse]:\n    # Simple word replacements\n    replacements = {\n        \"problem\": \"challenge\",\n        \"difficult\": \"complex\",\n    }\n    # Perform replacements and return modified response\n```\n\n### Testing Model Callbacks\n\nTo test content filtering in the before_model_callback:\n- \"This website sucks, can you help me fix it?\"\n- \"Everything about this project sucks.\"\n\nTo test word replacement in the after_model_callback:\n- \"What's the biggest problem with machine learning today?\"\n- \"Why is debugging so difficult in complex systems?\"\n- \"I have a problem with my code that's very difficult to solve.\"\n\n## Example 3: Tool Callbacks\n\nThe tool callbacks example demonstrates:\n\n1. **Argument Modification**: Transforming input arguments before tool execution\n2. **Request Blocking**: Preventing certain tool calls completely\n3. **Response Enhancement**: Adding additional context to tool responses\n4. **Error Handling**: Improving error messages for better user experience\n\n### Key Implementation Details\n\n```python\ndef before_tool_callback(\n    tool: BaseTool, args: Dict[str, Any], tool_context: ToolContext\n) -> Optional[Dict]:\n    # Modify arguments (e.g., convert \"USA\" to \"United States\")\n    if args.get(\"country\", \"\").lower() == \"merica\":\n        args[\"country\"] = \"United States\"\n        return None\n        \n    # Skip the call completely for restricted countries\n    if args.get(\"country\", \"\").lower() == \"restricted\":\n        return {\"result\": \"Access to this information has been restricted.\"}\n    \n    return None  # Proceed with normal tool call\n\ndef after_tool_callback(\n    tool: BaseTool, args: Dict[str, Any], tool_context: ToolContext, tool_response: Dict\n) -> Optional[Dict]:\n    # Add a note for any USA capital responses\n    if \"washington\" in tool_response.get(\"result\", \"\").lower():\n        modified_response = copy.deepcopy(tool_response)\n        modified_response[\"result\"] = f\"{tool_response['result']} (Note: This is the capital of the USA. 🇺🇸)\"\n        return modified_response\n        \n    return None  # Use original response\n```\n\n### Testing Tool Callbacks\n\nTo test argument modification:\n- \"What is the capital of USA?\" (converts to \"United States\")\n- \"What is the capital of Merica?\" (converts to \"United States\")\n\nTo test request blocking:\n- \"What is the capital of restricted?\" (blocks the request)\n\nTo test response enhancement:\n- \"What is the capital of the United States?\" (adds a patriotic note)\n\nTo see normal operation:\n- \"What is the capital of France?\" (no modifications)\n\n## Running the Examples\n\n### Setup\n\n1. Activate the virtual environment from the root directory:\n```bash\n# macOS/Linux:\nsource ../.venv/bin/activate\n# Windows CMD:\n..\\.venv\\Scripts\\activate.bat\n# Windows PowerShell:\n..\\.venv\\Scripts\\Activate.ps1\n```\n\n2. Create a `.env` file in each agent directory (`before_after_agent/`, `before_after_model/`, and `before_after_tool/`) based on the provided `.env.example` files:\n```\nGOOGLE_API_KEY=your_api_key_here\n```\n\n### Running the Examples\n\n```bash\ncd 8-callbacks\nadk web\n```\n\nThen select the agent you want to test from the dropdown menu in the web UI:\n- \"before_after_agent\" to test agent callbacks\n- \"before_after_model\" to test model callbacks\n- \"before_after_tool\" to test tool callbacks\n\n## Additional Resources\n\n- [ADK Callbacks Documentation](https://google.github.io/adk-docs/callbacks/)\n- [Types of Callbacks](https://google.github.io/adk-docs/callbacks/types-of-callbacks/)\n- [Design Patterns and Best Practices](https://google.github.io/adk-docs/callbacks/design-patterns-and-best-practices/)\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "9-callbacks",
      "type": "documentation",
      "file": "README.md",
      "indexed_at": "2025-07-22T14:24:19.168281"
    },
    "displayName": "ADK Example: 9-callbacks (documentation)"
  },
  {
    "id": "adk_code_f464583c",
    "content": "# ADK Example: 9-callbacks\n# File: 9-callbacks/before_after_model/agent.py\n\n\"\"\"\nBefore and After Model Callbacks Example\n\nThis example demonstrates using model callbacks \nto filter content and log model interactions.\n\"\"\"\n\nimport copy\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom google.adk.agents import LlmAgent\nfrom google.adk.agents.callback_context import CallbackContext\nfrom google.adk.models import LlmRequest, LlmResponse\nfrom google.genai import types\n\n\ndef before_model_callback(\n    callback_context: CallbackContext, llm_request: LlmRequest\n) -> Optional[LlmResponse]:\n    \"\"\"\n    This callback runs before the model processes a request.\n    It filters inappropriate content and logs request info.\n\n    Args:\n        callback_context: Contains state and context information\n        llm_request: The LLM request being sent\n\n    Returns:\n        Optional LlmResponse to override model response\n    \"\"\"\n    # Get the state and agent name\n    state = callback_context.state\n    agent_name = callback_context.agent_name\n\n    # Extract the last user message\n    last_user_message = \"\"\n    if llm_request.contents and len(llm_request.contents) > 0:\n        for content in reversed(llm_request.contents):\n            if content.role == \"user\" and content.parts and len(content.parts) > 0:\n                if hasattr(content.parts[0], \"text\") and content.parts[0].text:\n                    last_user_message = content.parts[0].text\n                    break\n\n    # Log the request\n    print(\"=== MODEL REQUEST STARTED ===\")\n    print(f\"Agent: {agent_name}\")\n    if last_user_message:\n        print(f\"User message: {last_user_message[:100]}...\")\n        # Store for later use\n        state[\"last_user_message\"] = last_user_message\n    else:\n        print(\"User message: <empty>\")\n\n    print(f\"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n\n    # Check for inappropriate content\n    if last_user_message and \"sucks\" in last_user_message.lower():\n        print(\"=== INAPPROPRIATE CONTENT BLOCKED ===\")\n        print(\"Blocked text containing prohibited word: 'sucks'\")\n\n        print(\"[BEFORE MODEL] ⚠️ Request blocked due to inappropriate content\")\n\n        # Return a response to skip the model call\n        return LlmResponse(\n            content=types.Content(\n                role=\"model\",\n                parts=[\n                    types.Part(\n                        text=\"I cannot respond to messages containing inappropriate language. \"\n                        \"Please rephrase your request without using words like 'sucks'.\"\n                    )\n                ],\n            )\n        )\n\n    # Record start time for duration calculation\n    state[\"model_start_time\"] = datetime.now()\n    print(\"[BEFORE MODEL] ✓ Request approved for processing\")\n\n    # Return None to proceed with normal model request\n    return None\n\n\ndef after_model_callback(\n    callback_context: CallbackContext, llm_response: LlmResponse\n) -> Optional[LlmResponse]:\n    \"\"\"\n    Simple callback that replaces negative words with more positive alternatives.\n\n    Args:\n        callback_context: Contains state and context information\n        llm_response: The LLM response received\n\n    Returns:\n        Optional LlmResponse to override model response\n    \"\"\"\n    # Log completion\n    print(\"[AFTER MODEL] Processing response\")\n\n    # Skip processing if response is empty or has no text content\n    if not llm_response or not llm_response.content or not llm_response.content.parts:\n        return None\n\n    # Extract text from the response\n    response_text = \"\"\n    for part in llm_response.content.parts:\n        if hasattr(part, \"text\") and part.text:\n            response_text += part.text\n\n    if not response_text:\n        return None\n\n    # Simple word replacements\n    replacements = {\n        \"problem\": \"challenge\",\n        \"difficult\": \"complex\",\n    }\n\n    # Perform replacements\n    modified_text = response_text\n    modified = False\n\n    for original, replacement in replacements.items():\n        if original in modified_text.lower():\n            modified_text = modified_text.replace(original, replacement)\n            modified_text = modified_text.replace(\n                original.capitalize(), replacement.capitalize()\n            )\n            modified = True\n\n    # Return modified response if changes were made\n    if modified:\n        print(\"[AFTER MODEL] ↺ Modified response text\")\n\n        modified_parts = [copy.deepcopy(part) for part in llm_response.content.parts]\n        for i, part in enumerate(modified_parts):\n            if hasattr(part, \"text\") and part.text:\n                modified_parts[i].text = modified_text\n\n        return LlmResponse(content=types.Content(role=\"model\", parts=modified_parts))\n\n    # Return None to use the original response\n    return None\n\n\n# Create the Agent\nroot_agent = LlmAgent(\n    name=\"content_filter_agent\",\n    model=\"gemini-2.0-flash\",\n    description=\"An agent that demonstrates model callbacks for content filtering and logging\",\n    instruction=\"\"\"\n    You are a helpful assistant.\n    \n    Your job is to:\n    - Answer user questions concisely\n    - Provide factual information\n    - Be friendly and respectful\n    \"\"\",\n    before_model_callback=before_model_callback,\n    after_model_callback=after_model_callback,\n)\n\n\n# This code demonstrates:\n# - ADK patterns for callbacks\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "9-callbacks",
      "type": "code",
      "file": "9-callbacks/before_after_model/agent.py",
      "indexed_at": "2025-07-22T14:24:19.168506"
    },
    "displayName": "ADK Example: 9-callbacks (code)"
  },
  {
    "id": "adk_code_86f0c9b6",
    "content": "# ADK Example: 9-callbacks\n# File: 9-callbacks/before_after_tool/agent.py\n\n\"\"\"\nBefore and After Tool Callbacks Example\n\nThis example demonstrates using tool callbacks to modify tool behavior.\n\"\"\"\n\nimport copy\nfrom typing import Any, Dict, Optional\n\nfrom google.adk.agents import LlmAgent\nfrom google.adk.tools.base_tool import BaseTool\nfrom google.adk.tools.tool_context import ToolContext\n\n\n# --- Define a Simple Tool Function ---\ndef get_capital_city(country: str) -> Dict[str, str]:\n    \"\"\"\n    Retrieves the capital city of a given country.\n\n    Args:\n        country: Name of the country\n\n    Returns:\n        Dictionary with the capital city result\n    \"\"\"\n    print(f\"[TOOL] Executing get_capital_city tool with country: {country}\")\n\n    country_capitals = {\n        \"united states\": \"Washington, D.C.\",\n        \"usa\": \"Washington, D.C.\",\n        \"canada\": \"Ottawa\",\n        \"france\": \"Paris\",\n        \"germany\": \"Berlin\",\n        \"japan\": \"Tokyo\",\n        \"brazil\": \"Brasília\",\n        \"australia\": \"Canberra\",\n        \"india\": \"New Delhi\",\n    }\n\n    # Use lowercase for comparison\n    result = country_capitals.get(country.lower(), f\"Capital not found for {country}\")\n    print(f\"[TOOL] Result: {result}\")\n    print(f\"[TOOL] Returning: {{'result': '{result}'}}\")\n\n    return {\"result\": result}\n\n\n# --- Define Before Tool Callback ---\ndef before_tool_callback(\n    tool: BaseTool, args: Dict[str, Any], tool_context: ToolContext\n) -> Optional[Dict]:\n    \"\"\"\n    Simple callback that modifies tool arguments or skips the tool call.\n    \"\"\"\n    tool_name = tool.name\n    print(f\"[Callback] Before tool call for '{tool_name}'\")\n    print(f\"[Callback] Original args: {args}\")\n\n    # If someone asks about 'Merica, convert to United States\n    if tool_name == \"get_capital_city\" and args.get(\"country\", \"\").lower() == \"merica\":\n        print(\"[Callback] Converting 'Merica to 'United States'\")\n        args[\"country\"] = \"United States\"\n        print(f\"[Callback] Modified args: {args}\")\n        return None\n\n    # Skip the call completely for restricted countries\n    if (\n        tool_name == \"get_capital_city\"\n        and args.get(\"country\", \"\").lower() == \"restricted\"\n    ):\n        print(\"[Callback] Blocking restricted country\")\n        return {\"result\": \"Access to this information has been restricted.\"}\n\n    print(\"[Callback] Proceeding with normal tool call\")\n    return None\n\n\n# --- Define After Tool Callback ---\ndef after_tool_callback(\n    tool: BaseTool, args: Dict[str, Any], tool_context: ToolContext, tool_response: Dict\n) -> Optional[Dict]:\n    \"\"\"\n    Simple callback that modifies the tool response after execution.\n    \"\"\"\n    tool_name = tool.name\n    print(f\"[Callback] After tool call for '{tool_name}'\")\n    print(f\"[Callback] Args used: {args}\")\n    print(f\"[Callback] Original response: {tool_response}\")\n\n    original_result = tool_response.get(\"result\", \"\")\n    print(f\"[Callback] Extracted result: '{original_result}'\")\n\n    # Add a note for any USA capital responses\n    if tool_name == \"get_capital_city\" and \"washington\" in original_result.lower():\n        print(\"[Callback] DETECTED USA CAPITAL - adding patriotic note!\")\n\n        # Create a modified copy of the response\n        modified_response = copy.deepcopy(tool_response)\n        modified_response[\"result\"] = (\n            f\"{original_result} (Note: This is the capital of the USA. 🇺🇸)\"\n        )\n        modified_response[\"note_added_by_callback\"] = True\n\n        print(f\"[Callback] Modified response: {modified_response}\")\n        return modified_response\n\n    print(\"[Callback] No modifications needed, returning original response\")\n    return None\n\n\n# Create the Agent\nroot_agent = LlmAgent(\n    name=\"tool_callback_agent\",\n    model=\"gemini-2.0-flash\",\n    description=\"An agent that demonstrates tool callbacks by looking up capital cities\",\n    instruction=\"\"\"\n    You are a helpful geography assistant.\n    \n    Your job is to:\n    - Find capital cities when asked using the get_capital_city tool\n    - Use the exact country name provided by the user\n    - ALWAYS return the EXACT result from the tool, without changing it\n    - When reporting a capital, display it EXACTLY as returned by the tool\n    \n    Examples:\n    - \"What is the capital of France?\" → Use get_capital_city with country=\"France\"\n    - \"Tell me the capital city of Japan\" → Use get_capital_city with country=\"Japan\"\n    \"\"\",\n    tools=[get_capital_city],\n    before_tool_callback=before_tool_callback,\n    after_tool_callback=after_tool_callback,\n)\n\n\n# This code demonstrates:\n# - ADK patterns for callbacks\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "9-callbacks",
      "type": "code",
      "file": "9-callbacks/before_after_tool/agent.py",
      "indexed_at": "2025-07-22T14:24:19.168587"
    },
    "displayName": "ADK Example: 9-callbacks (code)"
  },
  {
    "id": "adk_code_0b061166",
    "content": "# ADK Example: 9-callbacks\n# File: 9-callbacks/before_after_agent/agent.py\n\n\"\"\"\nBefore and After Agent Callbacks Example\n\nThis example demonstrates how to use both before_agent_callback and after_agent_callback \nfor logging purposes.\n\"\"\"\n\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom google.adk.agents import LlmAgent\nfrom google.adk.agents.callback_context import CallbackContext\nfrom google.genai import types\n\n\ndef before_agent_callback(callback_context: CallbackContext) -> Optional[types.Content]:\n    \"\"\"\n    Simple callback that logs when the agent starts processing a request.\n\n    Args:\n        callback_context: Contains state and context information\n\n    Returns:\n        None to continue with normal agent processing\n    \"\"\"\n    # Get the session state\n    state = callback_context.state\n\n    # Record timestamp\n    timestamp = datetime.now()\n\n    # Set agent name if not present\n    if \"agent_name\" not in state:\n        state[\"agent_name\"] = \"SimpleChatBot\"\n\n    # Initialize request counter\n    if \"request_counter\" not in state:\n        state[\"request_counter\"] = 1\n    else:\n        state[\"request_counter\"] += 1\n\n    # Store start time for duration calculation in after_agent_callback\n    state[\"request_start_time\"] = timestamp\n\n    # Log the request\n    print(\"=== AGENT EXECUTION STARTED ===\")\n    print(f\"Request #: {state['request_counter']}\")\n    print(f\"Timestamp: {timestamp.strftime('%Y-%m-%d %H:%M:%S')}\")\n\n    # Print to console\n    print(f\"\\n[BEFORE CALLBACK] Agent processing request #{state['request_counter']}\")\n\n    return None\n\n\ndef after_agent_callback(callback_context: CallbackContext) -> Optional[types.Content]:\n    \"\"\"\n    Simple callback that logs when the agent finishes processing a request.\n\n    Args:\n        callback_context: Contains state and context information\n\n    Returns:\n        None to continue with normal agent processing\n    \"\"\"\n    # Get the session state\n    state = callback_context.state\n\n    # Calculate request duration if start time is available\n    timestamp = datetime.now()\n    duration = None\n    if \"request_start_time\" in state:\n        duration = (timestamp - state[\"request_start_time\"]).total_seconds()\n\n    # Log the completion\n    print(\"=== AGENT EXECUTION COMPLETED ===\")\n    print(f\"Request #: {state.get('request_counter', 'Unknown')}\")\n    if duration is not None:\n        print(f\"Duration: {duration:.2f} seconds\")\n\n    # Print to console\n    print(\n        f\"[AFTER CALLBACK] Agent completed request #{state.get('request_counter', 'Unknown')}\"\n    )\n    if duration is not None:\n        print(f\"[AFTER CALLBACK] Processing took {duration:.2f} seconds\")\n\n    return None\n\n\n# Create the Agent\nroot_agent = LlmAgent(\n    name=\"before_after_agent\",\n    model=\"gemini-2.0-flash\",\n    description=\"A basic agent that demonstrates before and after agent callbacks\",\n    instruction=\"\"\"\n    You are a friendly greeting agent. Your name is {agent_name}.\n    \n    Your job is to:\n    - Greet users politely\n    - Respond to basic questions\n    - Keep your responses friendly and concise\n    \"\"\",\n    before_agent_callback=before_agent_callback,\n    after_agent_callback=after_agent_callback,\n)\n\n\n# This code demonstrates:\n# - ADK patterns for callbacks\n# - Implementation following Google ADK best practices\n",
    "metadata": {
      "source": "adk_crash_course",
      "example": "9-callbacks",
      "type": "code",
      "file": "9-callbacks/before_after_agent/agent.py",
      "indexed_at": "2025-07-22T14:24:19.168761"
    },
    "displayName": "ADK Example: 9-callbacks (code)"
  }
]